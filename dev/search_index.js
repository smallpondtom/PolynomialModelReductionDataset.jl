var documenterSearchIndex = {"docs":
[{"location":"1D/allencahn/#Allen-Cahn-equation","page":"Allen-Cahn equation","title":"Allen-Cahn equation","text":"","category":"section"},{"location":"1D/allencahn/#Overview","page":"Allen-Cahn equation","title":"Overview","text":"The Allen-Cahn equation is a fundamental partial differential equation (PDE) in the field of mathematical physics and materials science. Introduced by Samuel Allen and John W. Cahn in 1979, it models the process of phase separation in multi-component alloy systems, particularly the evolution of interfaces between different phases in a material.\n\nThe Allen-Cahn equation is typically written as:\n\nu_t = Delta u - F(u)\n\nu(xt): represents a scalar field, often associated with the order parameter or concentration difference between two phases at position x and time t.\nDelta: denotes the Laplacian operator, representing diffusion in space.\nF(u): A double-well potential function, commonly chosen as F(u) = frac14(u^2 - 1)^2. The derivative F(u)=u^3-u represents the reaction term driving the phase separation.","category":"section"},{"location":"1D/allencahn/#Physical-Interpretation","page":"Allen-Cahn equation","title":"Physical Interpretation","text":"Phase Separation: the equation models how a homogeneous mixture evolves into distinct phases over time, a process driven by minimization of the system's free energy.\nInterface Dynamics: it describes the motion of interfaces (or domain walls) between different phases, influenced by surface tension and curvature effects.","category":"section"},{"location":"1D/allencahn/#Some-properties","page":"Allen-Cahn equation","title":"Some properties","text":"Gradient Flow: the Allen-Cahn equation is the L_2-gradient flow of the Ginzburg-Landau energy functional:\nE(u) = int left( frac12nabla u^2 + F(u) right)dx\nThis means the evolution of u seeks to decrease the energy E(u) over time.\nConnection to Mean Curvature Flow: in the sharp interface limit (when the interface thickness tends to zero), the motion of the interface approximates mean curvature flow. This links the Allen-Cahn equation to geometric PDEs and has significant implications in differential geometry.\nMetastability: the equation exhibits metastable behavior, where solutions can remain in unstable equilibrium states for extended periods before transitioning to a stable configuration.","category":"section"},{"location":"1D/allencahn/#Model","page":"Allen-Cahn equation","title":"Model","text":"The Allen-Cahn equation becomes a cubic model:\n\ndotmathbfu(t) = mathbfAu(t) + mathbfG(mathbfu(t) otimes mathbfu(t) otimes mathbfu(t)) + mathbfBw(t)\n\nor \n\ndotmathbfu(t) = mathbfAu(t) + mathbfE(mathbfu(t) oslash mathbfu(t) oslash mathbfu(t)) + mathbfBw(t)\n\nwhere\n\nmathbfuinmathbbR^N: the state vector\nmathbfwinmathbbR^m: the input vector\nmathbfAinmathbbR^Ntimes N: the linear state matrix\nmathbfGinmathbbR^Ntimes N^3: the cubic state matrix with redundancy\nmathbfEinmathbbR^Ntimes N(N+1)(N+2)6: the cubic state matrix without redundancy\nmathbfBinmathbbR^Ntimes m: the control input matrix","category":"section"},{"location":"1D/allencahn/#Numerical-Integration","page":"Allen-Cahn equation","title":"Numerical Integration","text":"For the numerical integration we consider two methods:\n\nSemi-Implicit Crank-Nicolson (SICN)\nCrank-Nicolson Adam-Bashforth (CNAB)\n\nThe time stepping for each methods are \n\nSICN:\n\nmathbfu(t_k+1) = left(mathbfI-fracDelta t2mathbfAright)^-1 left left( mathbfI + fracDelta t2mathbfA right)mathbfu(t_k) + Delta tmathbfEmathbfu^langle 3rangle(t_k) + fracDelta t2 mathbfBleft mathbfw(t_k+1) + mathbfw(t_k) rightright\n\nCNAB:\n\nIf k=1\n\nmathbfu(t_k+1) = left(mathbfI-fracDelta t2mathbfAright)^-1 left left( mathbfI + fracDelta t2mathbfA right)mathbfu(t_k) + Delta tmathbfEmathbfu^langle 3rangle(t_k) + fracDelta t2 mathbfBleft mathbfw(t_k+1) + mathbfw(t_k) rightright\n\nIf kgeq 2\n\nmathbfu(t_k+1) = left(mathbfI-fracDelta t2mathbfAright)^-1 left left( mathbfI + fracDelta t2mathbfA right)mathbfu(t_k) + frac3Delta t2mathbfEmathbfu^langle 3rangle(t_k) - fracDelta t2mathbfEmathbfu^langle 3rangle(t_k-1) + fracDelta t2 mathbfBleft mathbfw(t_k+1) + mathbfw(t_k) rightright\n\nwhere mathbfu^langle 3 rangle=mathbfu oslash mathbfu oslash mathbfu.\n\n!!! Note     Please go over the derivations in 1D heat equation and Viscous Burgers' equation for details on how to construct each operators.","category":"section"},{"location":"1D/allencahn/#Example","page":"Allen-Cahn equation","title":"Example","text":"using CairoMakie\nusing LinearAlgebra\nusing PolynomialModelReductionDataset: AllenCahnModel\n\n# Setup\nΩ = (-1.0, 1.0)\nT = (0.0, 3.0)\nNx = 2^8\ndt = 1e-3\nallencahn = AllenCahnModel(\n    spatial_domain=Ω, time_domain=T, Δx=((Ω[2]-Ω[1]) + 1/Nx)/Nx, Δt=dt, \n    params=Dict(:μ => 0.001, :ϵ => 1.0), BC=:dirichlet\n)\nDS = 10\nallencahn.IC = 0.53*allencahn.xspan + 0.47*sin.(-1.5π * allencahn.xspan)\nUbc1 = ones(1,allencahn.time_dim)\nUbc2 = -ones(1,allencahn.time_dim)\nUbc = [Ubc1; Ubc2]\n\n# Operators\nA, E, B = allencahn.finite_diff_model(allencahn, allencahn.params)\n\n# Integrate\nU = allencahn.integrate_model(\n    allencahn.tspan, allencahn.IC, Ubc; \n    linear_matrix=A, cubic_matrix=E, control_matrix=B,\n    system_input=true, integrator_type=:CNAB,\n)\n\n# Surface plot\nfig3, _, sf = CairoMakie.surface(allencahn.xspan, allencahn.tspan[1:DS:end], U[:, 1:DS:end], \n    axis=(type=Axis3, xlabel=L\"x\", ylabel=L\"t\", zlabel=L\"u(x,t)\"))\nCairoMakie.Colorbar(fig3[1, 2], sf)\nfig3\n\n# Flow field\nfig4, ax, hm = CairoMakie.heatmap(allencahn.xspan, allencahn.tspan[1:DS:end], U[:, 1:DS:end])\nax.xlabel = L\"x\"\nax.ylabel = L\"t\"\nCairoMakie.Colorbar(fig4[1, 2], hm)\nfig4","category":"section"},{"location":"1D/allencahn/#API","page":"Allen-Cahn equation","title":"API","text":"","category":"section"},{"location":"1D/allencahn/#PolynomialModelReductionDataset.AllenCahn1D.AllenCahnModel","page":"Allen-Cahn equation","title":"PolynomialModelReductionDataset.AllenCahn1D.AllenCahnModel","text":"mutable struct AllenCahnModel <: AbstractModel\n\nAllen-Cahn equation Model\n\nfracpartial upartial t =  mufracpartial^2 upartial x^2 - epsilon(u^3 - u)\n\nwhere u is the state variable, μ is the diffusion coefficient, ϵ is a nonlinear coefficient.\n\nFields\n\nspatial_domain::Tuple{Real,Real}: spatial domain\ntime_domain::Tuple{Real,Real}: temporal domain\nparam_domain::Tuple{Real,Real}: parameter domain (diffusion coeff)\nΔx::Real: spatial grid size\nΔt::Real: temporal step size\nparams::Dict{Symbol,Union{Real,AbstractArray{<:Real}}}: parameters\nxspan::Vector{<:Real}: spatial grid points\ntspan::Vector{<:Real}: temporal points\nspatial_dim::Int: spatial dimension\ntime_dim::Int: temporal dimension\nparam_dim::Int: parameter dimension\nIC::AbstractArray{<:Real}: initial condition\nBC::Symbol: boundary condition\nfinite_diff_model::Function: model using Finite Difference\nintegrate_model::Function: integrator using Crank-Nicholson (linear) Explicit (nonlinear) method\n\n\n\n\n\n","category":"type"},{"location":"1D/allencahn/#PolynomialModelReductionDataset.AllenCahn1D","page":"Allen-Cahn equation","title":"PolynomialModelReductionDataset.AllenCahn1D","text":"Allen-Cahn equation PDE Model\n\n\n\n\n\n","category":"module"},{"location":"1D/allencahn/#PolynomialModelReductionDataset.AllenCahn1D.finite_diff_dirichlet_model-Tuple{Real, Real, Dict}","page":"Allen-Cahn equation","title":"PolynomialModelReductionDataset.AllenCahn1D.finite_diff_dirichlet_model","text":"finite_diff_dirichlet_model(N, Δx, params)\n\n\n\n\n\n\n","category":"method"},{"location":"1D/allencahn/#PolynomialModelReductionDataset.AllenCahn1D.finite_diff_mixed_model-Tuple{Real, Real, Dict}","page":"Allen-Cahn equation","title":"PolynomialModelReductionDataset.AllenCahn1D.finite_diff_mixed_model","text":"finite_diff_mixed_model(N, Δx, params)\n\n\nCreate the matrices A (linear operator), B (input operator), and E (cubic operator) for Chafee-Infante  model using the mixed boundary condition. If the spatial domain is [0,1], then we assume u(0,t) to be  homogeneous dirichlet boundary condition and u(1,t) to be Neumann boundary condition of some function h(t).\n\nArguments\n\nN::Real: spatial dimension\nΔx::Real: spatial grid size\nparams::Dict: parameters\n\nReturns\n\nA::SparseMatrixCSC{Float64,Int}: linear operator\nB::SparseMatrixCSC{Float64,Int}: input operator\nE::SparseMatrixCSC{Float64,Int}: cubic operator\n\n\n\n\n\n","category":"method"},{"location":"1D/allencahn/#PolynomialModelReductionDataset.AllenCahn1D.finite_diff_model-Tuple{PolynomialModelReductionDataset.AllenCahn1D.AllenCahnModel, Dict}","page":"Allen-Cahn equation","title":"PolynomialModelReductionDataset.AllenCahn1D.finite_diff_model","text":"finite_diff_model(model, params)\n\n\nCreate the matrices A (linear operator) and E (cubic operator) for the Allen-Cahn model.\n\nArguments\n\nmodel::AllenCahnModel: Allen-Cahn model\nparams::Dict: parameters dictionary\n\n\n\n\n\n","category":"method"},{"location":"1D/allencahn/#PolynomialModelReductionDataset.AllenCahn1D.finite_diff_periodic_model-Tuple{Real, Real, Dict}","page":"Allen-Cahn equation","title":"PolynomialModelReductionDataset.AllenCahn1D.finite_diff_periodic_model","text":"finite_diff_periodic_model(N, Δx, params)\n\n\nCreate the matrices A (linear operator) and E (cubic operator) for the Chafee-Infante model.\n\nArguments\n\nN::Real: spatial dimension\nΔx::Real: spatial grid size\nparams::Dict: parameters\n\nReturns\n\nA::SparseMatrixCSC{Float64,Int}: linear operator\nE::SparseMatrixCSC{Float64,Int}: cubic operator\n\n\n\n\n\n","category":"method"},{"location":"1D/allencahn/#PolynomialModelReductionDataset.AllenCahn1D.integrate_model-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractArray{T}}} where T<:Real","page":"Allen-Cahn equation","title":"PolynomialModelReductionDataset.AllenCahn1D.integrate_model","text":"integrate_model(tdata, u0; ...)\nintegrate_model(tdata, u0, input; kwargs...)\n\n\nIntegrate the Allen-Cahn model using the Crank-Nicholson (linear) Adam-Bashforth (nonlinear) method (CNAB) or Semi-Implicit Crank-Nicolson (SICN) method.\n\nArguments\n\ntdata::AbstractArray{T}: time data\nu0::AbstractArray{T}: initial condition\ninput::AbstractArray{T}=[]: input data\n\nKeyword Arguments\n\nlinear_matrix::AbstractArray{T,2}: linear matrix\ncubic_matrix::AbstractArray{T,2}: cubic matrix\ncontrol_matrix::AbstractArray{T,2}: control matrix\nsystem_input::Bool=false: system input flag\nconst_stepsize::Bool=false: constant step size flag\nu3_jm1::AbstractArray{T}=[]: previous cubic term\n\nReturns\n\nx::Array{T,2}: integrated model states\n\nNotes\n\nIf system_input is true, then control_matrix must be provided.\nIf const_stepsize is true, then the time step size is assumed to be constant.\nIf u3_jm1 is provided, then the cubic term at the previous time step is used.\nintegrator_type can be either :SICN for Semi-Implicit Crank-Nicolson or :CNAB for Crank-Nicolson Adam-Bashforth\n\n\n\n\n\n","category":"method"},{"location":"1D/allencahn/#PolynomialModelReductionDataset.AllenCahn1D.integrate_model_with_control_CNAB-Tuple{Any, Any, Any}","page":"Allen-Cahn equation","title":"PolynomialModelReductionDataset.AllenCahn1D.integrate_model_with_control_CNAB","text":"integrate_model_with_control_CNAB(\n    tdata,\n    u0,\n    input;\n    linear_matrix,\n    cubic_matrix,\n    control_matrix,\n    const_stepsize,\n    u3_jm1\n)\n\n\nIntegrate the Allen-Cahn model using the Crank-Nicholson (linear) Adam-Bashforth (nonlinear) method (CNAB) with control.\n\n\n\n\n\n","category":"method"},{"location":"1D/allencahn/#PolynomialModelReductionDataset.AllenCahn1D.integrate_model_with_control_SICN-Tuple{Any, Any, Any}","page":"Allen-Cahn equation","title":"PolynomialModelReductionDataset.AllenCahn1D.integrate_model_with_control_SICN","text":"integrate_model_with_control_SICN(\n    tdata,\n    u0,\n    input;\n    linear_matrix,\n    cubic_matrix,\n    control_matrix,\n    const_stepsize\n)\n\n\nIntegrate the Allen-Cahn model using the Crank-Nicholson (linear) Explicit (nonlinear) method. Or Semi-Implicit Crank-Nicholson (SICN) method with control input.\n\n\n\n\n\n","category":"method"},{"location":"1D/allencahn/#PolynomialModelReductionDataset.AllenCahn1D.integrate_model_without_control_CNAB-Tuple{Any, Any}","page":"Allen-Cahn equation","title":"PolynomialModelReductionDataset.AllenCahn1D.integrate_model_without_control_CNAB","text":"integrate_model_without_control_CNAB(\n    tdata,\n    u0;\n    linear_matrix,\n    cubic_matrix,\n    const_stepsize,\n    u3_jm1\n)\n\n\nIntegrate the Allen-Cahn model using the Crank-Nicholson (linear) Adam-Bashforth (nonlinear) method (CNAB) without control.\n\n\n\n\n\n","category":"method"},{"location":"1D/allencahn/#PolynomialModelReductionDataset.AllenCahn1D.integrate_model_without_control_SICN-Tuple{Any, Any}","page":"Allen-Cahn equation","title":"PolynomialModelReductionDataset.AllenCahn1D.integrate_model_without_control_SICN","text":"integrate_model_without_control_SICN(\n    tdata,\n    u0;\n    linear_matrix,\n    cubic_matrix,\n    const_stepsize\n)\n\n\nIntegrate the Allen-Cahn model using the Crank-Nicholson (linear) Explicit (nonlinear) method. Or, in other words, Semi-Implicit Crank-Nicholson (SICN) method without control.\n\n\n\n\n\n","category":"method"},{"location":"1D/gardner/#Gardner-Equation","page":"Gardner Equation","title":"Gardner Equation","text":"","category":"section"},{"location":"1D/gardner/#Overview","page":"Gardner Equation","title":"Overview","text":"The Gardner equation, also known as the combined Korteweg-de Vries-modified Korteweg-de Vries (KdV-mKdV) equation, is a nonlinear partial differential equation (PDE) that unifies the Korteweg-de Vries (KdV) and the modified Korteweg-de Vries (mKdV) equations. It models the propagation of nonlinear waves in dispersive media and is significant in the study of soliton interactions, integrable systems, and nonlinear wave phenomena in fluid dynamics and plasma physics.\n\nThe standard form of the Gardner equation in one spatial dimension is:\n\nu_t = -alpha u_xxx + beta uu_x + gamma u^2 u_x\n\nWhere:\n\nu(x t) is the wave profile at position x and time t.\nalpha, beta, and gamma are constants representing the strengths of the linear and nonlinear terms and dispersion, respectively.","category":"section"},{"location":"1D/gardner/#Key-Features","page":"Gardner Equation","title":"Key Features","text":"Combination of Nonlinearities: The Gardner equation includes both quadratic (u fracpartial upartial x) and cubic (u^2 fracpartial upartial x) nonlinear terms, bridging the KdV and mKdV equations.\nDispersion: The term alpha fracpartial^3 upartial x^3 accounts for dispersive effects, crucial for balancing nonlinearity to form solitons.\nIntegrability: The equation is integrable via the inverse scattering transform (IST), indicating the existence of multi-soliton solutions and infinite conservation laws.\nSoliton Interactions: Models complex interactions between solitons, including the fusion and fission of solitary waves.","category":"section"},{"location":"1D/gardner/#Physical-Interpretation","page":"Gardner Equation","title":"Physical Interpretation","text":"Fluid Dynamics: Describes shallow water waves in channels where both quadratic and cubic nonlinear effects are significant.\nPlasma Physics: Models ion-acoustic waves in plasma with non-Maxwellian electron distributions or in the presence of multiple ion species.\nInternal Waves: Represents internal solitary waves in stratified fluids where density variations lead to modified nonlinear effects.","category":"section"},{"location":"1D/gardner/#Properties","page":"Gardner Equation","title":"Properties","text":"","category":"section"},{"location":"1D/gardner/#Soliton-Solutions","page":"Gardner Equation","title":"Soliton Solutions","text":"One-Soliton Solution: The Gardner equation admits exact one-soliton solutions, which can be written as:\nu(x t) = A operatornamesech^2 left( k (x - v t - x_0) right) + B operatornamesech left( k (x - v t - x_0) right)\nWhere:\nA, B, and k are constants determined by alpha, beta, gamma, and the soliton parameters.\nv is the velocity of the soliton.\nx_0 is the initial position.\nMulti-Soliton Solutions: Due to its integrability, the equation supports multi-soliton solutions that interact elastically.","category":"section"},{"location":"1D/gardner/#Transformations","page":"Gardner Equation","title":"Transformations","text":"Miura Transformation: The Gardner equation relates to the KdV and mKdV equations through transformations, enabling the mapping of solutions between these equations.\nFrom mKdV to KdV:\nu_mathrmKdV = u_mathrmmKdV^2 + lambda u_mathrmmKdV_x\nWhere lambda is a parameter.\nBäcklund Transformations: Used to generate new solutions from known ones, further illustrating the integrable nature of the equation.","category":"section"},{"location":"1D/gardner/#Applications","page":"Gardner Equation","title":"Applications","text":"Shallow Water Waves: Modeling wave propagation in channels or coastal areas where higher-order nonlinear effects are non-negligible.\nPlasma Physics: Studying soliton dynamics in plasmas with complex ion compositions or temperature distributions.\nNonlinear Optics: Describing pulse propagation in optical fibers where both quadratic and cubic nonlinearities are present.\nInternal Solitary Waves: Investigating waves within oceans or atmospheres where density stratification affects wave behavior.","category":"section"},{"location":"1D/gardner/#Generalizations","page":"Gardner Equation","title":"Generalizations","text":"Variable Coefficient Gardner Equation: Incorporates spatial or temporal variations in coefficients to model inhomogeneous or non-stationary media.\nfracpartial upartial t + alpha(x t) u fracpartial upartial x + beta(x t) u^2 fracpartial upartial x + gamma(x t) fracpartial^3 upartial x^3 = 0\nHigher Dimensions: Extensions to two or three spatial dimensions for more complex wave phenomena.\nNon-Integrable Perturbations: Adding terms that break integrability to study the effects of perturbations on soliton dynamics.","category":"section"},{"location":"1D/gardner/#Model","page":"Gardner Equation","title":"Model","text":"The Gardner equation becomes a quadratic and cubic model:\n\ndotmathbfu(t) = mathbfAu(t) + mathbfH(mathbfu(t) otimes mathbfu(t)) + mathbfG(mathbfu(t) otimes mathbfu(t) otimes mathbfu(t)) + mathbfBw(t)\n\nor \n\ndotmathbfu(t) = mathbfAu(t) + mathbfF(mathbfu(t) oslash mathbfu(t)) + mathbfE(mathbfu(t) oslash mathbfu(t) oslash mathbfu(t)) + mathbfBw(t)\n\nwhere\n\nmathbfuinmathbbR^N: the state vector\nmathbfwinmathbbR^m: the input vector\nmathbfAinmathbbR^Ntimes N: the linear state matrix\nmathbfHinmathbbR^Ntimes N^2: the quadratic state matrix with redundancy\nmathbfFinmathbbR^Ntimes N(N+1)2: the quadratic state matrix without redundancy\nmathbfGinmathbbR^Ntimes N^3: the cubic state matrix with redundancy\nmathbfEinmathbbR^Ntimes N(N+1)(N+2)6: the cubic state matrix without redundancy\nmathbfBinmathbbR^Ntimes m: the control input matrix","category":"section"},{"location":"1D/gardner/#Numerical-Integration","page":"Gardner Equation","title":"Numerical Integration","text":"For the numerical integration we consider two methods:\n\nSemi-Implicit Euler (SIE)\nCrank-Nicolson Adam-Bashforth (CNAB)\n\nFor the exact expressions of the time-stepping check Allen-Cahn equation.","category":"section"},{"location":"1D/gardner/#Examples","page":"Gardner Equation","title":"Examples","text":"using CairoMakie\nusing LinearAlgebra\nusing PolynomialModelReductionDataset: GardnerModel\n\n# Setup\nΩ = (0.0, 3.0)\nNx = 2^8; dt = 1e-3\ngardner = GardnerModel(\n    spatial_domain=Ω, time_domain=(0.0, 3.0), Δx=(Ω[2] + 1/Nx)/Nx, Δt=dt,\n    params=Dict(:a => -0.397, :b => -1.0278, :c => -0.18151), BC=:dirichlet,\n)\nDS = 100\ngardner.IC = cos.(2π * gardner.xspan / (Ω[2] - Ω[1])) # + 0.5 * cos.(4π * gardner.xspan / (Ω[2] - Ω[1]))\nUbc1 = ones(1,gardner.time_dim)\nUbc2 = -ones(1,gardner.time_dim)\nUbc = [Ubc1; Ubc2]\n\n# Operators\nA, F, E, B = gardner.finite_diff_model(gardner, gardner.params)\n\n# Integrate\nU = gardner.integrate_model(\n    gardner.tspan, gardner.IC, Ubc; \n    linear_matrix=A, quadratic_matrix=F, cubic_matrix=E, control_matrix=B,\n    system_input=true, integrator_type=:CNAB,\n)\n\n# Surface plot\nfig3, _, sf = CairoMakie.surface(gardner.xspan, gardner.tspan[1:DS:end], U[:, 1:DS:end], \n    axis=(type=Axis3, xlabel=L\"x\", ylabel=L\"t\", zlabel=L\"u(x,t)\"))\nCairoMakie.Colorbar(fig3[1, 2], sf)\nfig3\n\n# Flow field\nfig4, ax, hm = CairoMakie.heatmap(gardner.xspan, gardner.tspan[1:DS:end], U[:, 1:DS:end])\nax.xlabel = L\"x\"\nax.ylabel = L\"t\"\nCairoMakie.Colorbar(fig4[1, 2], hm)\nfig4","category":"section"},{"location":"1D/gardner/#API","page":"Gardner Equation","title":"API","text":"","category":"section"},{"location":"1D/gardner/#PolynomialModelReductionDataset.Gardner.GardnerModel","page":"Gardner Equation","title":"PolynomialModelReductionDataset.Gardner.GardnerModel","text":"mutable struct GardnerModel <: AbstractModel\n\nGardner equation model\n\nfracpartial upartial t = -alphafracpartial^3 upartial x^3 - beta ufracpartial upartial x - gamma u^2fracpartial upartial x\n\nFields\n\nspatial_domain::Tuple{Real,Real}: spatial domain\ntime_domain::Tuple{Real,Real}: temporal domain\nparam_domain::Tuple{Real,Real}: parameter domain\nΔx::Real: spatial grid size\nΔt::Real: temporal step size\nBC::Symbol: boundary condition\nIC::Array{Float64}: initial condition\nxspan::Vector{Float64}: spatial grid points\ntspan::Vector{Float64}: temporal points\nspatial_dim::Int64: spatial dimension\ntime_dim::Int64: temporal dimension\nparams::Union{Real,AbstractArray{<:Real}}: parameter vector\nparam_dim::Int64: parameter dimension\nfinite_diff_model::Function: model using Finite Difference\nintegrate_model::Function: model integration\n\n\n\n\n\n","category":"type"},{"location":"1D/gardner/#PolynomialModelReductionDataset.Gardner","page":"Gardner Equation","title":"PolynomialModelReductionDataset.Gardner","text":"Gardner PDE model\n\n\n\n\n\n","category":"module"},{"location":"1D/gardner/#PolynomialModelReductionDataset.Gardner.finite_diff_dirichlet_model-Tuple{Real, Real, Real, Dict}","page":"Gardner Equation","title":"PolynomialModelReductionDataset.Gardner.finite_diff_dirichlet_model","text":"finite_diff_dirichlet_model(N, Δx, Δt, params)\n\n\nGenerate A, F, E, B matrices for the Gardner equation for Dirichlet boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"1D/gardner/#PolynomialModelReductionDataset.Gardner.finite_diff_model-Tuple{PolynomialModelReductionDataset.Gardner.GardnerModel, Dict}","page":"Gardner Equation","title":"PolynomialModelReductionDataset.Gardner.finite_diff_model","text":"finite_diff_model(model, params)\n\n\nFinite Difference Model for Gardner equation\n\nArguments\n\nmodel::GardnerModel: Gardner model\nparams::Real: params including a, b, c\n\nReturns\n\noperators\n\n\n\n\n\n","category":"method"},{"location":"1D/gardner/#PolynomialModelReductionDataset.Gardner.finite_diff_periodic_model-Tuple{Real, Real, Dict}","page":"Gardner Equation","title":"PolynomialModelReductionDataset.Gardner.finite_diff_periodic_model","text":"finite_diff_periodic_model(N::Real, Δx::Real, params::Dict) → A, F, E\n\nGenerate A, F, E matrices for the Gardner equation for periodic boundary condition (Non-conservative).\n\n\n\n\n\n","category":"method"},{"location":"1D/gardner/#PolynomialModelReductionDataset.Gardner.integrate_model_with_control_CNAB-Tuple{Any, Any, Any}","page":"Gardner Equation","title":"PolynomialModelReductionDataset.Gardner.integrate_model_with_control_CNAB","text":"integrate_model_with_control_CNAB(\n    tdata,\n    u0,\n    input;\n    linear_matrix,\n    quadratic_matrix,\n    cubic_matrix,\n    control_matrix,\n    const_stepsize,\n    u2_jm1,\n    u3_jm1\n)\n\n\nCrank-Nicolson Adam-Bashforth (CNAB) scheme with control\n\n\n\n\n\n","category":"method"},{"location":"1D/gardner/#PolynomialModelReductionDataset.Gardner.integrate_model_with_control_SIE-Tuple{Any, Any, Any}","page":"Gardner Equation","title":"PolynomialModelReductionDataset.Gardner.integrate_model_with_control_SIE","text":"integrate_model_with_control_SIE(\n    tdata,\n    u0,\n    input;\n    linear_matrix,\n    quadratic_matrix,\n    cubic_matrix,\n    control_matrix\n)\n\n\nSemi-Implicit Euler scheme with control\n\n\n\n\n\n","category":"method"},{"location":"1D/gardner/#PolynomialModelReductionDataset.Gardner.integrate_model_without_control_CNAB-Tuple{Any, Any}","page":"Gardner Equation","title":"PolynomialModelReductionDataset.Gardner.integrate_model_without_control_CNAB","text":"integrate_model_without_control_CNAB(\n    tdata,\n    u0;\n    linear_matrix,\n    quadratic_matrix,\n    cubic_matrix,\n    const_stepsize,\n    u2_jm1,\n    u3_jm1\n)\n\n\nCrank-Nicolson Adam-Bashforth (CNAB) scheme without control\n\n\n\n\n\n","category":"method"},{"location":"1D/gardner/#PolynomialModelReductionDataset.Gardner.integrate_model_without_control_SIE-Tuple{Any, Any}","page":"Gardner Equation","title":"PolynomialModelReductionDataset.Gardner.integrate_model_without_control_SIE","text":"integrate_model_without_control_SIE(\n    tdata,\n    u0;\n    linear_matrix,\n    quadratic_matrix,\n    cubic_matrix\n)\n\n\nSemi-Implicit Euler scheme without control\n\n\n\n\n\n","category":"method"},{"location":"1D/burgers/#Viscous-Burgers'-Equation","page":"Viscous Burgers' Equation","title":"Viscous Burgers' Equation","text":"","category":"section"},{"location":"1D/burgers/#Overview","page":"Viscous Burgers' Equation","title":"Overview","text":"The viscous Burger's equation or viscous Bateman-Burger's equation is a second order PDE used widely in many fields as a simplified model, for example, fluid mechanics, acoustics, etc. The state u(xt) is a velocity field consisting of the spatial and temporal variables. The PDE is expressed as \n\nu_t = mu u_xx - uu_x\n\nwhere \n\nbeginalign\nu_t = fracpartial u(tx)partial t \nu_x = fracpartial u(tx)partial x \nu_xx = fracpartial^2 u(tx)partial x^2\nendalign\n\nfor xin0L, and mu is the viscosity parameter. ","category":"section"},{"location":"1D/burgers/#Finite-Difference-Model","page":"Viscous Burgers' Equation","title":"Finite Difference Model","text":"Let k = 123ldotsK and n = 0 123ldotsN. Further let u^k_j indicate the state u at the k-th discrete time and n-th discrete spatial point. With this discrete expression we can express u_t, u_x, and u_xx as follows.\n\nbeginalign\nu_t = fracpartial u(t_kx_n)partial t = fracu^k+1_n - u^k_nDelta t + mathcalO(Delta t) \nu_x = fracpartial u(t_kx_n)partial t = fracu^k_n+1 - u^k_n-12Delta x + mathcalO(Delta x) \nu_xx = fracpartial^2 u(t_kx_n)partial x^2 = fracu^k_n+1 - 2u^k_n + u^k_n-1Delta x^2 + mathcalO(Delta x^2)\nendalign\n\nFor u_t we use the standard first order finite difference, and for u_xx we use the second order central finite difference and since we will implement the semi-implicit integration (backward Euler for only this term without the viscid term). Now, if we look carefully, we see that for u_x we use the leap-frog finite difference where we jump from the (n+1)-th term to the (n-1)-th term. Plugging in the above expressions and with some abuse of notation we have\n\nbegingather\n    u_t  =  mufracu^k+1_n+1 - 2u^k+1_n + u^k+1_n-1Delta x^2 - u_n^k fracu^k_n+1 - u^k_n-12Delta x\nendgather\n\nFrom this, we can form the system matrices, but keep in mind that for the Burger's equation we include the boundary conditions in the A and F matrix unlike the 1D heat equation example. This is because we see that the quadratic term also includes the (n+1)- and (n-1)-th term requiring the state vector to contain the terms from u_0 all the way to u_N+1. To deal with this, assuming constant time-step, we approximate the time derivative of the state variables corresponding to the boundary as \n\nbeginalign\n    dot u_0 = fracu_0^k+1 - u_0^kDelta t \n    dot u_N+1 = fracu_N+1^k+1 - u_N+1^kDelta t \nendalign\n\nIf we have Dirichlet boundary condition \n\nu(0t) = g(t) qquad u(Lt) = h(t)\n\nthen\n\nbeginalign\n    dot u_0 = frac1Delta tg(t_k+1) - frac1Delta tu_0^k \n    dot u_N+1 = frac1Delta th(t_k+1) - frac1Delta tu_N+1^k\nendalign\n\nTo accommodate for the time derivative terms of the boundary, we construct the linear system matrix and control matrix as follows:\n\nbegingather\nA = fracmuDelta x^2 beginbmatrix\nfracDelta x^2muleft( -frac1Delta t right)  0  0  0  0  cdots  0  0\n1  -2  1  0  0  cdots  0  0\n0  1  -2  1  0  cdots  0  0\n0  0  1  -2  1  cdots  0  0\n0  0  0  1  -2  cdots  0  0\nvdots  vdots  vdots  vdots  vdots  ddots  vdots vdots \n0  0  0  0  0  cdots  -2  1 \n0  0  0  0  0  cdots  0  fracDelta x^2mu left( -frac1Delta t right)\nendbmatrix\nendgather\n\nand \n\nbegingather\nB = beginbmatrix\nfrac1Delta t  0 05em 0  0  vdots  vdots  0  0 05em 0  frac1Delta t\nendbmatrix\nendgather\n\nIn A, besides the first and last rows, we have a tridiagonal toeplitz matrix formed by the stencil 1-2 1. However, the first and last rows of matrices A and B construct the finite difference at the boundaries.\n\nThe F matrix, which is the quadratic operator without the non-redundancy from the symmetry of Kronecker products, is a bit tricky to wrap your mind around. So let's go through it with examples. First, let u_n in mathbbR^3 where n = 012, then \n\nbegingather\nu^(2) = beginbmatrix\n    u_0^2  u_1u_0  u_2u_0  u_1^2  u_2u_1  u_2^2 \nendbmatrix^top\nendgather\n\nand \n\nbegingather\n    F = frac12Delta x beginbmatrix\n        0  0  0  0  0  0 \n        0  1  0  0  -1  0 \n        0  0  0  0  0  0\n    endbmatrix\nendgather\n\nThe first and last rows of F are all zeros since the quadratic operator does not contribute to the boundary conditions, and the middle row have non-zero entries for the u_nu_n-1 and u_nu_n+1 terms where n=1 in this case. Similarly, for u_n in mathbbR^4 where n = 0123, then \n\nbegingather\nu^(2) = beginbmatrix\n    u_0^2  u_1u_0  u_2u_0  u_3u_0  u_1^2  u_2u_1  u_3u_1  u_2^2  u_3u_2  u_3^2\nendbmatrix^top\nendgather\n\nand \n\nbegingather\n    F = frac12Delta x beginbmatrix\n        0  0  0  0  0  0  0  0  0  0\n        0  1  0  0  0  -1  0  0  0  0\n        0  0  0  0  0  1  0  0  -1  0\n        0  0  0  0  0  0  0  0  0  0\n    endbmatrix\nendgather\n\nwhere the first and last rows are zeros and the second and third rows have non-zero elements for the u_nu_n-1 and u_nu_n+1 terms. Note that the sequence which represents the row with nonzero entries in the F matrix can be represented as \n\nbegingather\n    begincases\n        a_1 = 2 \n        a_n+1 = a_n + N - n + 1\n    endcases\nendgather\n\nwhere N is the total number of variables, which leads to\n\nbegingather\n    a_n = a_1 + sum_k=1^n-1(N - k + 1) = 2 - frac12n(n-1) + (N+1)(n-1) \nendgather\n\nThus the we arrive at a N-dimensional nonlinear ODE:\n\ndotmathbfu(t) = mathbfAu(t) + mathbfF(mathbfu(t) oslash mathbfu(t)) + mathbfBw(t)\n\nwhere mathbfuinmathbbR^N, oslash indicates the unique Kronecker product which omits the redundant terms from the standard Kronecker product, and mathbfw = g(t)h(t)^top in mathbbR^2 is the input vector.\n\nFor numerical integration, we apply the semi-implicit Euler where the linear term is implicit and the quadratic and control terms are explicit. The time-stepping expression is defined by\n\nbegingather\nmathbfu(t_k+1) = (mathbfI - Delta t mathbfA)^-1leftmathbfu(t_k) + Delta tFleftmathbfu(t_k) oslash mathbfu(t_k) right + Delta t Bmathbfw(t_k+1)right\nendgather\n\nYou can follow the same procedure for the periodic, Neumann, mixed, and other boundary conditions, which I will leave as an exercise for you.","category":"section"},{"location":"1D/burgers/#Conservativeness","page":"Viscous Burgers' Equation","title":"Conservativeness","text":"For the periodic model, we consider 3 different models which are:\n\nconservative form: u_t = mu u_xx + nabla_x (frac12u^2)\nnon-conservative form: u_t = mu u_xx + uu_x\nenergy-preserving form which is a convex combination of the conservative and non-conservative forms with a weight of 13 which preserves the energy of the system [2]","category":"section"},{"location":"1D/burgers/#Example","page":"Viscous Burgers' Equation","title":"Example","text":"The example below uses the settings from [1].\n\nusing CairoMakie\nusing LinearAlgebra\nusing PolynomialModelReductionDataset: BurgersModel\n\n# Setup\nΩ = (0.0, 1.0)\nNx = 2^7; dt = 1e-4\nburgers = BurgersModel(\n    spatial_domain=Ω, time_domain=(0.0, 1.0), Δx=(Ω[2] + 1/Nx)/Nx, Δt=dt,\n    diffusion_coeffs=0.1, BC=:dirichlet,\n)\nUbc = rand(burgers.time_dim) # boundary condition\n\n# Model operators\nA, F, B = burgers.finite_diff_model(burgers, burgers.diffusion_coeffs; opposite_sign_on_ends=true)\n\n# Integrate\nU = burgers.integrate_model(\n    burgers.tspan, burgers.IC, Ubc; \n    linear_matrix=A, control_matrix=B, quadratic_matrix=F,\n    system_input=true\n)\n\n# Surface plot\nfig1, _, sf = CairoMakie.surface(burgers.xspan, burgers.tspan, U, \n    axis=(type=Axis3, xlabel=L\"x\", ylabel=L\"t\", zlabel=L\"u(x,t)\"))\nCairoMakie.Colorbar(fig1[1, 2], sf)\nfig1\n\n# Flow field\nfig2, ax, hm = CairoMakie.heatmap(burgers.xspan, burgers.tspan, U)\nax.xlabel = L\"x\"\nax.ylabel = L\"t\"\nCairoMakie.Colorbar(fig2[1, 2], hm)\nfig2","category":"section"},{"location":"1D/burgers/#API","page":"Viscous Burgers' Equation","title":"API","text":"","category":"section"},{"location":"1D/burgers/#PolynomialModelReductionDataset.Burgers.BurgersModel","page":"Viscous Burgers' Equation","title":"PolynomialModelReductionDataset.Burgers.BurgersModel","text":"mutable struct BurgersModel <: AbstractModel\n\nViscous Burgers' equation model\n\nfracpartial upartial t = mufracpartial^2 upartial x^2 - ufracpartial upartial x\n\nFields\n\nspatial_domain::Tuple{Real,Real}: spatial domain\ntime_domain::Tuple{Real,Real}: temporal domain\nparam_domain::Tuple{Real,Real}: parameter domain\nΔx::Real: spatial grid size\nΔt::Real: temporal step size\nBC::Symbol: boundary condition\nIC::Array{Float64}: initial condition\nxspan::Vector{Float64}: spatial grid points\ntspan::Vector{Float64}: temporal points\ndiffusion_coeffs::Union{Real,AbstractArray{<:Real}}: parameter vector\nspatial_dim::Int64: spatial dimension\ntime_dim::Int64: temporal dimension\nparam_dim::Int64: parameter dimension\nconservation_type::Symbol: conservation type\nfinite_diff_model::Function: model using Finite Difference\nintegrate_model::Function: model integration\n\nNote\n\nThe conservation type can be either :EP (Energy Preserving), :NC (Non-Conservative), or :C (Conservative).\n\n\n\n\n\n","category":"type"},{"location":"1D/burgers/#PolynomialModelReductionDataset.Burgers","page":"Viscous Burgers' Equation","title":"PolynomialModelReductionDataset.Burgers","text":"Viscous Burgers' equation model\n\n\n\n\n\n","category":"module"},{"location":"1D/burgers/#PolynomialModelReductionDataset.Burgers.finite_diff_dirichlet_model-Tuple{Real, Real, Real, Float64}","page":"Viscous Burgers' Equation","title":"PolynomialModelReductionDataset.Burgers.finite_diff_dirichlet_model","text":"finite_diff_dirichlet_model(\n    N,\n    Δx,\n    Δt,\n    μ;\n    same_on_both_ends,\n    opposite_sign_on_ends\n)\n\n\nGenerate A, F, B matrices for the Burgers' equation for Dirichlet boundary condition. This is by default the non-conservative form.\n\n\n\n\n\n","category":"method"},{"location":"1D/burgers/#PolynomialModelReductionDataset.Burgers.finite_diff_model-Tuple{PolynomialModelReductionDataset.Burgers.BurgersModel, Real}","page":"Viscous Burgers' Equation","title":"PolynomialModelReductionDataset.Burgers.finite_diff_model","text":"finite_diff_model(model, μ; kwargs...)\n\n\nFinite Difference Model for Burgers equation\n\nArguments\n\nmodel::BurgersModel: Burgers model\nμ::Real: diffusion coefficient\n\nReturns\n\noperators\n\n\n\n\n\n","category":"method"},{"location":"1D/burgers/#PolynomialModelReductionDataset.Burgers.finite_diff_periodic_conservative_model-Tuple{Real, Real, Float64}","page":"Viscous Burgers' Equation","title":"PolynomialModelReductionDataset.Burgers.finite_diff_periodic_conservative_model","text":"finite_diff_periodic_conservative_model(N, Δx, μ)\n\n\nGenerate A, F matrices for the Burgers' equation for periodic boundary condition (Conservative form).\n\n\n\n\n\n","category":"method"},{"location":"1D/burgers/#PolynomialModelReductionDataset.Burgers.finite_diff_periodic_energy_preserving_model-Tuple{Real, Real, Float64}","page":"Viscous Burgers' Equation","title":"PolynomialModelReductionDataset.Burgers.finite_diff_periodic_energy_preserving_model","text":"finite_diff_periodic_energy_preserving_model(N, Δx, μ)\n\n\nGenerate A, F matrices for the Burgers' equation for periodic boundary condition (Energy preserving form).\n\n\n\n\n\n","category":"method"},{"location":"1D/burgers/#PolynomialModelReductionDataset.Burgers.finite_diff_periodic_nonconservative_model-Tuple{Real, Real, Real}","page":"Viscous Burgers' Equation","title":"PolynomialModelReductionDataset.Burgers.finite_diff_periodic_nonconservative_model","text":"finite_diff_periodic_nonconservative_model(N, Δx, μ)\n\n\nGenerate A, F matrices for the Burgers' equation for periodic boundary condition (Non-conservative).\n\n\n\n\n\n","category":"method"},{"location":"1D/burgers/#PolynomialModelReductionDataset.Burgers.integrate_model-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractArray{T}}} where T<:Real","page":"Viscous Burgers' Equation","title":"PolynomialModelReductionDataset.Burgers.integrate_model","text":"integrate_model(tdata, u0; ...)\nintegrate_model(tdata, u0, input; kwargs...)\n\n\nIntegrate the viscous Burgers' equation model\n\nArguments\n\ntdata::AbstractArray{T}: time data\nu0::AbstractArray{T}: initial condition\ninput::AbstractArray{T}=[]: input data\n\nKeyword Arguments\n\nlinear_matrix::AbstractArray{T}: linear matrix\nquadratic_matrix::AbstractArray{T}: quadratic matrix\ncontrol_matrix::AbstractArray{T}=[]: control matrix\nsystem_input::Bool=false: system input flag\nintegrator_type::Symbol=:ForwardEuler: integrator type\nsame_on_both_ends::Bool=false: same (Dirichlet) boundary condition on both ends\nopposite_sign_on_ends::Bool=true: opposite sign (Dirichlet) boundary condition on both ends\n\nReturns\n\nu::Array{T,2}: integrated model states\n\nNotes\n\nInput is assumed to be a matrix of size (spatial dimension x time dimension). You will receive a warning if the input is a tall vector/column vector.\n\n\n\n\n\n","category":"method"},{"location":"1D/burgers/#PolynomialModelReductionDataset.Burgers.integrate_model_with_control-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractArray{T}}} where T<:Real","page":"Viscous Burgers' Equation","title":"PolynomialModelReductionDataset.Burgers.integrate_model_with_control","text":"integrate_model_with_control(\n    tdata,\n    u0,\n    input;\n    linear_matrix,\n    quadratic_matrix,\n    control_matrix\n)\n\n\nSemi-Implicit Euler scheme with control\n\n\n\n\n\n","category":"method"},{"location":"1D/burgers/#PolynomialModelReductionDataset.Burgers.integrate_model_without_control-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}} where T<:Real","page":"Viscous Burgers' Equation","title":"PolynomialModelReductionDataset.Burgers.integrate_model_without_control","text":"integrate_model_without_control(\n    tdata,\n    u0;\n    linear_matrix,\n    quadratic_matrix\n)\n\n\nSemi-Implicit Euler scheme without control\n\n\n\n\n\n","category":"method"},{"location":"1D/fhn/#FitzHugh-Nagumo-Equation","page":"FitzHugh-Nagumo Equation","title":"FitzHugh-Nagumo Equation","text":"","category":"section"},{"location":"1D/fhn/#Overview","page":"FitzHugh-Nagumo Equation","title":"Overview","text":"The Fitzhugh-Nagumo equation is a simplified mathematical model used to describe the behavior of excitable systems, particularly the dynamics of nerve cells or neurons. It was developed independently by Richard Fitzhugh and John Nagumo in the 1960s as a modification of the Hodgkin-Huxley model, aiming to capture the essential characteristics of action potential propagation.\n\nThe equation takes the form of a system of ordinary differential equations and consists of two main variables: a fast-recovery variable (usually denoted as v) and a slow-activating variable (usually denoted as w). The Fitzhugh-Nagumo equation is given by:\n\nbeginalign*\n    fracdvdt = v - fracv^33 - w + I \n    fracdwdt = epsilon (v + a - bw)\nendalign*\n\nwhere:\n\nv: represents the membrane potential of the neuron.\nw: represents a recovery variable related to the inactivation of ion channels.\nI: is an external input current that stimulates the neuron.\nepsilon: is a positive parameter that controls the timescale separation between v and w dynamics.\na and b are constants that affect the equilibrium points and behavior of the system.\n\nThe Fitzhugh-Nagumo model simplifies the complex behavior of neurons, focusing on the interplay between the fast-responding action potential and the slower recovery process. This simplification makes it easier to analyze and understand the fundamental mechanisms underlying excitable systems. The Fitzhugh-Nagumo equation has been widely used in the study of neuronal dynamics, cardiac rhythm modeling, and other excitable phenomena, providing insights into the generation and propagation of electrical signals in various biological and physical contexts.","category":"section"},{"location":"1D/fhn/#Model","page":"FitzHugh-Nagumo Equation","title":"Model","text":"The Fitzhugh-Nagumo model can be modelled as a quadratic-bilinear system after a process called lifting \n\ndotmathbfu(t) = mathbfAu(t) + mathbfH(mathbfu(t) otimes mathbfu(t)) + mathbfBw(t) + mathbfNu(t)mathbfw(t) + mathbfK\n\nor\n\ndotmathbfu(t) = mathbfAu(t) + mathbfF(mathbfu(t) oslash mathbfu(t)) + mathbfBw(t)+ mathbfNu(t)mathbfw(t) + mathbfK\n\nwhere\n\nmathbfuinmathbbR^N: the state vector\nmathbfwinmathbbR^m: the input vector\nmathbfAinmathbbR^Ntimes N: the linear state matrix\nmathbfHinmathbbR^Ntimes N^2: the quadratic state matrix with redundancy\nmathbfFinmathbbR^Ntimes N(N+1)2: the quadratic state matrix without redundancy\nmathbfBinmathbbR^Ntimes m: the control input matrix\nmathbfNinmathbbR^Ntimes N: the bilinear matrix\nmathbfKinmathbbR^N: the constant matrix\n\nFor full details on the model see The MORwiki Community [3] and Qian et al. [4].","category":"section"},{"location":"1D/fhn/#Numerical-Integration","page":"FitzHugh-Nagumo Equation","title":"Numerical Integration","text":"The numerical integration is handled by standard forward Euler scheme.","category":"section"},{"location":"1D/fhn/#Example","page":"FitzHugh-Nagumo Equation","title":"Example","text":"This example is a reproduction of the example in Qian et al. [4].\n\nusing CairoMakie\nusing Kronecker: ⊗\nusing LinearAlgebra\nusing PolynomialModelReductionDataset: FitzHughNagumoModel\n\n# Setup\nΩ = (0.0, 1.0); dt = 1e-4; Nx = 2^9\nfhn = FitzHughNagumoModel(\n    spatial_domain=Ω, time_domain=(0.0,4.0), Δx=(Ω[2] - 1/Nx)/Nx, Δt=dt,\n    alpha_input_params=500, beta_input_params=10,\n)\nα = 500; β = 10\ng(t) = α * t^3 * exp(-β * t)\nU = g.(fhn.tspan)'\nDS = 100  # downsample rate\n\n# Operators\nAf, Bf, Cf, Kf, f = fhn.full_order_model(fhn.spatial_dim, fhn.spatial_domain[2])\nfom(x, u) = Af * x + Bf * u + f(x,u) + Kf\n\n# Integrate\nX = fhn.integrate_model(fhn.tspan, fhn.IC, g; functional=fom)[:, 1:DS:end]\n\n# Plot solution\nfig1 = Figure()\ngp = fhn.spatial_dim\nax1 = Axis(fig1[1, 1], xlabel=\"t\", ylabel=\"x\", title=\"x1\")\nhm1 = CairoMakie.heatmap!(ax1, fhn.tspan[1:DS:end], fhn.xspan, X[1:gp, :]')\nCairoMakie.Colorbar(fig1[1, 2], hm1)\nax2 = Axis(fig1[1, 3], xlabel=\"t\", ylabel=\"x\", title=\"x2\")\nhm2 = CairoMakie.heatmap!(ax2, fhn.tspan[1:DS:end], fhn.xspan, X[gp+1:end, :]')\nCairoMakie.Colorbar(fig1[1, 4], hm2)\nfig1","category":"section"},{"location":"1D/fhn/#API","page":"FitzHugh-Nagumo Equation","title":"API","text":"","category":"section"},{"location":"1D/fhn/#PolynomialModelReductionDataset.FitzHughNagumo.FitzHughNagumoModel","page":"FitzHugh-Nagumo Equation","title":"PolynomialModelReductionDataset.FitzHughNagumo.FitzHughNagumoModel","text":"mutable struct FitzHughNagumoModel <: AbstractModel\n\nFitzHugh-Nagumo model\n\nbeginaligned\nfracpartial upartial t =  epsilon^2fracpartial^2 upartial x^2 + u(u-01)(1-u) - v + g \nfracpartial vpartial t = hu + gamma v + g\nendaligned\n\nwhere u and v are the state variables, g is the control input, and h, gamma, and epsilon are the parameters. Specifically, for this problem we assume the control input to begin\n\ng(t) = alpha t^3 exp(-beta t)\n\nwhere alpha and beta are the parameters that are going to be varied for training.\n\nFields\n\nspatial_domain::Tuple{Real,Real}: spatial domain\ntime_domain::Tuple{Real,Real}: temporal domain\nalpha_input_param_domain::Tuple{Real,Real}: parameter domain\nbeta_input_param_domain::Tuple{Real,Real}: parameter domain\nΔx::Real: spatial grid size\nΔt::Real: temporal step size\nBC::Symbol: boundary condition\nIC::Array{Float64}: initial condition\nIC_lift::Array{Float64}: initial condition\nxspan::Vector{Float64}: spatial grid points\ntspan::Vector{Float64}: temporal points\nalpha_input_params::Union{Real,AbstractArray{<:Real}}: input parameter vector\nbeta_input_params::Union{Real,AbstractArray{<:Real}}: input parameter vector\nspatial_dim::Int64: spatial dimension\ntime_dim::Int64: temporal dimension\nparam_dim::Dict{Symbol,<:Int}: parameter dimension\nfull_order_model::Function: full order model\nlifted_finite_diff_model::Function: lifted finite difference model\n\n\n\n\n\n","category":"type"},{"location":"1D/fhn/#PolynomialModelReductionDataset.FitzHughNagumo","page":"FitzHugh-Nagumo Equation","title":"PolynomialModelReductionDataset.FitzHughNagumo","text":"Fitz-Hugh Nagumo PDE model\n\n\n\n\n\n","category":"module"},{"location":"1D/fhn/#PolynomialModelReductionDataset.FitzHughNagumo.full_order_model-Tuple{Any, Any}","page":"FitzHugh-Nagumo Equation","title":"PolynomialModelReductionDataset.FitzHughNagumo.full_order_model","text":"full_order_model(k, l) → A, B, C, K, f\n\nCreate the full order operators with the nonlinear operator expressed as f(x). \n\nArguments\n\nk::Int64: number of spatial grid points\nl::Float64: spatial domain length\n\nReturns\n\nA::SparseMatrixCSC{Float64,Int64}: A matrix\nB::SparseMatrixCSC{Float64,Int64}: B matrix\nC::SparseMatrixCSC{Float64,Int64}: C matrix\nK::SparseMatrixCSC{Float64,Int64}: K matrix\nf::Function: nonlinear operator\n\n\n\n\n\n","category":"method"},{"location":"1D/fhn/#PolynomialModelReductionDataset.FitzHughNagumo.integrate_model-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, Union{Function, AbstractArray{T}}}} where T<:Real","page":"FitzHugh-Nagumo Equation","title":"PolynomialModelReductionDataset.FitzHughNagumo.integrate_model","text":"integrate_model(tdata, u0; ...)\nintegrate_model(tdata, u0, input; kwargs...)\n\n\nIntegrate the FitzHugh-Nagumo PDE model.\n\nArguments\n\ntdata::AbstractVector{T}: time data\nu0::AbstractVector{T}: initial condition\ninput::Union{AbstractArray{T},Function}: input function or matrix\n\nKeyword Arguments\n\nfunctional::Function: functional operator\n\nReturns\n\nu::Array{T,2}: state variables\n\n\n\n\n\n","category":"method"},{"location":"1D/fhn/#PolynomialModelReductionDataset.FitzHughNagumo.lifted_finite_diff_model-Tuple{Any, Any}","page":"FitzHugh-Nagumo Equation","title":"PolynomialModelReductionDataset.FitzHughNagumo.lifted_finite_diff_model","text":"lifted_finite_diff_model(k, l) → A, B, C, H, N, K\n\nGenerate the full order operators used for the intrusive model operators\n\nArguments\n\nk::Int64: number of spatial grid points\nl::Float64: spatial domain length\n\nReturns\n\nA::SparseMatrixCSC{Float64,Int64}: A matrix\nB::SparseMatrixCSC{Float64,Int64}: B matrix\nC::SparseMatrixCSC{Float64,Int64}: C matrix\nH::SparseMatrixCSC{Float64,Int64}: H matrix\nN::SparseMatrixCSC{Float64,Int64}: N matrix\nK::SparseMatrixCSC{Float64,Int64}: K matrix\n\n\n\n\n\n","category":"method"},{"location":"1D/dgb/#Damped-Gardner-Burgers-Equation","page":"Damped Gardner-Burgers Equation","title":"Damped Gardner-Burgers Equation","text":"","category":"section"},{"location":"1D/dgb/#Overview","page":"Damped Gardner-Burgers Equation","title":"Overview","text":"This equation is a modified version of the Gardner equation where the diffusion term u_xx and damping term u is added for stability. The equation is defined by\n\nu_t = -alpha u_xxx + beta uu_x + gamma u^2 u_x + delta u_xx + epsilon u","category":"section"},{"location":"1D/dgb/#Model","page":"Damped Gardner-Burgers Equation","title":"Model","text":"The damped Gardner-Burgers equation becomes the exact same as the original Gardner equation:\n\ndotmathbfu(t) = mathbfAu(t) + mathbfH(mathbfu(t) otimes mathbfu(t)) + mathbfG(mathbfu(t) otimes mathbfu(t) otimes mathbfu(t)) + mathbfBw(t)\n\nor \n\ndotmathbfu(t) = mathbfAu(t) + mathbfF(mathbfu(t) oslash mathbfu(t)) + mathbfE(mathbfu(t) oslash mathbfu(t) oslash mathbfu(t)) + mathbfBw(t)\n\nwhere\n\nmathbfuinmathbbR^N: the state vector\nmathbfwinmathbbR^m: the input vector\nmathbfAinmathbbR^Ntimes N: the linear state matrix\nmathbfHinmathbbR^Ntimes N^2: the quadratic state matrix with redundancy\nmathbfFinmathbbR^Ntimes N(N+1)2: the quadratic state matrix without redundancy\nmathbfGinmathbbR^Ntimes N^3: the cubic state matrix with redundancy\nmathbfEinmathbbR^Ntimes N(N+1)(N+2)6: the cubic state matrix without redundancy\nmathbfBinmathbbR^Ntimes m: the control input matrix","category":"section"},{"location":"1D/dgb/#Numerical-Integration","page":"Damped Gardner-Burgers Equation","title":"Numerical Integration","text":"For the numerical integration we consider two methods:\n\nSemi-Implicit Euler (SIE)\nCrank-Nicolson Adam-Bashforth (CNAB)\n\nFor the exact expressions of the time-stepping check Allen-Cahn equation.","category":"section"},{"location":"1D/dgb/#Examples","page":"Damped Gardner-Burgers Equation","title":"Examples","text":"using CairoMakie\nusing LinearAlgebra\nusing PolynomialModelReductionDataset: DampedGardnerBurgersModel\n\n# Setup\nΩ = (0.0, 3.0)\nNx = 2^8; dt = 1e-3\ndgb = DampedGardnerBurgersModel(\n    spatial_domain=Ω, time_domain=(0.0, 3.0), Δx=(Ω[2] + 1/Nx)/Nx, Δt=dt,\n    params=Dict(:a => 1, :b => 3, :c => 5, :d => 0.2, :e => 0.5), BC=:dirichlet,\n)\nDS = 100\ndgb.IC = 2 * cos.(2π * dgb.xspan / (Ω[2] - Ω[1])) # + 0.5 * cos.(4π * dgb.xspan / (Ω[2] - Ω[1]))\nUbc1 = 0.5ones(1,dgb.time_dim)\nUbc2 = -0.5ones(1,dgb.time_dim)\nUbc = [Ubc1; Ubc2]\n\n# Operators\nA, F, E, B = dgb.finite_diff_model(dgb, dgb.params)\n\n# Integrate\nU = dgb.integrate_model(\n    dgb.tspan, dgb.IC, Ubc; \n    linear_matrix=A, quadratic_matrix=F, cubic_matrix=E, control_matrix=B,\n    system_input=true, integrator_type=:CNAB,\n)\n\n# Surface plot\nfig3, _, sf = CairoMakie.surface(dgb.xspan, dgb.tspan[1:DS:end], U[:, 1:DS:end], \n    axis=(type=Axis3, xlabel=L\"x\", ylabel=L\"t\", zlabel=L\"u(x,t)\"))\nCairoMakie.Colorbar(fig3[1, 2], sf)\nfig3\n\n# Flow field\nfig4, ax, hm = CairoMakie.heatmap(dgb.xspan, dgb.tspan[1:DS:end], U[:, 1:DS:end])\nax.xlabel = L\"x\"\nax.ylabel = L\"t\"\nCairoMakie.Colorbar(fig4[1, 2], hm)\nfig4","category":"section"},{"location":"1D/dgb/#API","page":"Damped Gardner-Burgers Equation","title":"API","text":"","category":"section"},{"location":"1D/dgb/#PolynomialModelReductionDataset.DampedGardnerBurgers.DampedGardnerBurgersModel","page":"Damped Gardner-Burgers Equation","title":"PolynomialModelReductionDataset.DampedGardnerBurgers.DampedGardnerBurgersModel","text":"mutable struct DampedGardnerBurgersModel <: AbstractModel\n\nDamped Gardner-Burgers equation model\n\nfracpartial upartial t = -alphafracpartial^3 upartial x^3 - beta ufracpartial upartial x - gamma u^2fracpartial upartial x + delta fracpartial^2 upartial x^2 + epsilon u\n\nFields\n\nspatial_domain::Tuple{Real,Real}: spatial domain\ntime_domain::Tuple{Real,Real}: temporal domain\nparam_domain::Tuple{Real,Real}: parameter domain\nΔx::Real: spatial grid size\nΔt::Real: temporal step size\nBC::Symbol: boundary condition\nIC::Array{Float64}: initial condition\nxspan::Vector{Float64}: spatial grid points\ntspan::Vector{Float64}: temporal points\nspatial_dim::Int64: spatial dimension\ntime_dim::Int64: temporal dimension\nparams::Union{Real,AbstractArray{<:Real}}: parameter vector\nparam_dim::Int64: parameter dimension\nfinite_diff_model::Function: model using Finite Difference\nintegrate_model::Function: model integration\n\n\n\n\n\n","category":"type"},{"location":"1D/dgb/#PolynomialModelReductionDataset.DampedGardnerBurgers","page":"Damped Gardner-Burgers Equation","title":"PolynomialModelReductionDataset.DampedGardnerBurgers","text":"Damped Gardner-Burgers (DGB) PDE model\n\n\n\n\n\n","category":"module"},{"location":"1D/dgb/#PolynomialModelReductionDataset.DampedGardnerBurgers.finite_diff_dirichlet_model-Tuple{Real, Real, Real, Dict}","page":"Damped Gardner-Burgers Equation","title":"PolynomialModelReductionDataset.DampedGardnerBurgers.finite_diff_dirichlet_model","text":"finite_diff_dirichlet_model(N, Δx, Δt, params)\n\n\nGenerate A, F, E, B matrices for the Gardner equation for Dirichlet boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"1D/dgb/#PolynomialModelReductionDataset.DampedGardnerBurgers.finite_diff_model-Tuple{PolynomialModelReductionDataset.DampedGardnerBurgers.DampedGardnerBurgersModel, Dict}","page":"Damped Gardner-Burgers Equation","title":"PolynomialModelReductionDataset.DampedGardnerBurgers.finite_diff_model","text":"finite_diff_model(model, params)\n\n\nFinite Difference Model for Gardner equation\n\nArguments\n\nmodel::DampedGardnerBurgersModel: Gardner model\nparams::Real: params including a, b, c\n\nReturns\n\noperators\n\n\n\n\n\n","category":"method"},{"location":"1D/dgb/#PolynomialModelReductionDataset.DampedGardnerBurgers.finite_diff_periodic_model-Tuple{Real, Real, Dict}","page":"Damped Gardner-Burgers Equation","title":"PolynomialModelReductionDataset.DampedGardnerBurgers.finite_diff_periodic_model","text":"finite_diff_periodic_model(N, Δx, params)\n\n\nGenerate A, F, E matrices for the Gardner equation for periodic boundary condition (Non-conservative).\n\n\n\n\n\n","category":"method"},{"location":"1D/dgb/#PolynomialModelReductionDataset.DampedGardnerBurgers.integrate_model-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractArray{T}}} where T<:Real","page":"Damped Gardner-Burgers Equation","title":"PolynomialModelReductionDataset.DampedGardnerBurgers.integrate_model","text":"integrate_model(tdata, u0; ...)\nintegrate_model(tdata, u0, input; kwargs...)\n\n\nIntegrate the Damped Gardner-Burgers model using 2 different methods:\n\nSemi-Implicit Euler (SIE)\nCrank-Nicolson Adam-Bashforth (CNAB)\n\nArguments\n\ntdata::AbstractArray{T}: time data\nu0::AbstractArray{T}: initial condition\ninput::AbstractArray{T}=[]: input data\n\nKeyword Arguments\n\nlinear_matrix::AbstractArray{T,2}: linear matrix\nquadratic_matrix::AbstractArray{T,2}: quadratic matrix\ncubic_matrix::AbstractArray{T,2}: cubic matrix\ncontrol_matrix::AbstractArray{T,2}: control matrix\nsystem_input::Bool=false: system input\nconst_stepsize::Bool=false: constant step size\nu2_jm1::Union{Nothing,AbstractArray{T}}=nothing: u2 at j-1\nu3_jm1::Union{Nothing,AbstractArray{T}}=nothing: u3 at j-1\nintegrator_type::Symbol=:CNAB: integrator type\n\nReturns\n\nu::AbstractArray{T}: solution\n\nNotes\n\nIf system_input=true, then the control matrix must be provided\nIf const_stepsize=true, then the time step size is assumed to be constant\nIf u2_jm1 and u3_jm1 are provided, then the CNAB scheme is used\nIf integrator_type=:SIE, then the Semi-Implicit Euler scheme is used\nIf integrator_type=:CNAB, then the Crank-Nicolson Adam-Bashforth scheme is used\n\n\n\n\n\n","category":"method"},{"location":"1D/dgb/#PolynomialModelReductionDataset.DampedGardnerBurgers.integrate_model_with_control_CNAB-Tuple{Any, Any, Any}","page":"Damped Gardner-Burgers Equation","title":"PolynomialModelReductionDataset.DampedGardnerBurgers.integrate_model_with_control_CNAB","text":"integrate_model_with_control_CNAB(\n    tdata,\n    u0,\n    input;\n    linear_matrix,\n    quadratic_matrix,\n    cubic_matrix,\n    control_matrix,\n    const_stepsize,\n    u2_jm1,\n    u3_jm1\n)\n\n\nCrank-Nicolson Adam-Bashforth (CNAB) scheme with control\n\n\n\n\n\n","category":"method"},{"location":"1D/dgb/#PolynomialModelReductionDataset.DampedGardnerBurgers.integrate_model_with_control_SIE-Tuple{Any, Any, Any}","page":"Damped Gardner-Burgers Equation","title":"PolynomialModelReductionDataset.DampedGardnerBurgers.integrate_model_with_control_SIE","text":"integrate_model_with_control_SIE(\n    tdata,\n    u0,\n    input;\n    linear_matrix,\n    quadratic_matrix,\n    cubic_matrix,\n    control_matrix\n)\n\n\nSemi-Implicit Euler scheme with control\n\n\n\n\n\n","category":"method"},{"location":"1D/dgb/#PolynomialModelReductionDataset.DampedGardnerBurgers.integrate_model_without_control_CNAB-Tuple{Any, Any}","page":"Damped Gardner-Burgers Equation","title":"PolynomialModelReductionDataset.DampedGardnerBurgers.integrate_model_without_control_CNAB","text":"integrate_model_without_control_CNAB(\n    tdata,\n    u0;\n    linear_matrix,\n    quadratic_matrix,\n    cubic_matrix,\n    const_stepsize,\n    u2_jm1,\n    u3_jm1\n)\n\n\nCrank-Nicolson Adam-Bashforth (CNAB) scheme without control\n\n\n\n\n\n","category":"method"},{"location":"1D/dgb/#PolynomialModelReductionDataset.DampedGardnerBurgers.integrate_model_without_control_SIE-Tuple{Any, Any}","page":"Damped Gardner-Burgers Equation","title":"PolynomialModelReductionDataset.DampedGardnerBurgers.integrate_model_without_control_SIE","text":"integrate_model_without_control_SIE(\n    tdata,\n    u0;\n    linear_matrix,\n    quadratic_matrix,\n    cubic_matrix\n)\n\n\nSemi-Implicit Euler scheme without control\n\n\n\n\n\n","category":"method"},{"location":"paper/#Paper","page":"Paper Reference","title":"Paper","text":"Below you have a list of publications referenced in this work.\n\nB. Peherstorfer and K. Willcox. Data-Driven Operator Inference for Nonintrusive Projection-Based Model Reduction. Computer Methods in Applied Mechanics and Engineering 306, 196–215 (2016).\n\n\n\nH. Aref and P. K. Daripa. Note on Finite Difference Approximations to Burgers' Equation. SIAM Journal on Scientific and Statistical Computing 5, 856–864 (1984).\n\n\n\nThe MORwiki Community. FitzHugh-Nagumo System. MORwiki – Model Order Reduction Wiki (2018).\n\n\n\nE. Qian, B. Kramer, B. Peherstorfer and K. Willcox. Lift & Learn: Physics-informed Machine Learning for Large-Scale Nonlinear Dynamical Systems. Physica D: Nonlinear Phenomena 406, 132401 (2020).\n\n\n\nT. Koike and E. Qian. Energy-Preserving Reduced Operator Inference for Efficient Design and Control. In: AIAA SCITECH 2024 Forum (2024); p. 1012.\n\n\n\n","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Pages = [\"api.md\"]","category":"section"},{"location":"api/#API","page":"API Reference","title":"API","text":"All APIs of PolynomialModelReductionDataset listed in a unstructured manner.","category":"section"},{"location":"api/#PolynomialModelReductionDataset.adjust_input-Tuple{Any, Any, Any}","page":"API Reference","title":"PolynomialModelReductionDataset.adjust_input","text":"adjust_input(input, input_dim, tdim; margin)\n\n\nArguments\n\ninput: input data\ninput_dim::Int: input dimension\ntdim::Int: time dimension\nmargin::Int=2: margin for time dimension (error protection)\n\nReturns\n\ninput::Array{T,2}: adjusted input\n\n\n\n\n\n","category":"method"},{"location":"1D/heat1d/#1D-Heat-Equation","page":"1D Heat","title":"1D Heat Equation","text":"","category":"section"},{"location":"1D/heat1d/#Overview","page":"1D Heat","title":"Overview","text":"The heat equation is a fundamental partial differential equation that describes the diffusion of heat in a given medium over time. It is used to model how temperature changes spread through materials, such as solids, liquids, and gases. The equation is given by:\n\nu_t = mu u_xx\n\nwhere \n\nbeginalign\nu_t = fracpartial u(tx)partial t \nu_xx = fracpartial^2 u(tx)partial x^2\nendalign\n\nwhere xin0L is the temperature and mu is the thermal diffusivity parameter.  ","category":"section"},{"location":"1D/heat1d/#Finite-Difference-Model","page":"1D Heat","title":"Finite Difference Model","text":"In order to spatially discretize this PDE to obtain the ODE, which we can numerically integrate, we use the finite difference approach. Let k = 123ldotsK and n = 123ldotsN. This means that we are spatially discretizing this PDE using N spatial grid points. Then let u^k_n indicate the state u at the k-th discrete time and n-th discrete spatial point. With this discrete expression we can express u_t and u_xx as follows.\n\nbeginalign\nu_t = fracpartial u(t_kx_n)partial t = fracu^k+1_n - u^k_nDelta t + mathcalO(Delta t) \nu_xx = fracpartial^2 u(t_kx_n)partial x^2 = fracu^k_n+1 - 2u^k_n + u^k_n-1Delta x^2 + mathcalO(Delta x^2)\nendalign\n\nThe equations above represent the finite difference for the forward Euler approach. For the backward Euler approach it will change slightly (discussed below). It follows that \n\nbegingather\nu_t  =  mufracu^k_n+1 - 2u^k_n + u^k_n-1Delta x^2\nendgather\n\nThe right-hand side represents the well-known tridiagonal structure arising from the Laplacian operator. Note that, we are abusing some notations since the finite difference method is an approximation where the higher-order terms are truncated, and people use the capital U to denote the approximated state variables.\n\nu_xx approx U_xx = fracu^k_n+1 - 2u^k_n + u^k_n-1Delta x^2\n\nNow, if we consider all points corresponding to each spatial grid point, the ODE can be represented as \n\ndotmathbfu = mathbfAmathbfu\n\nwhere \n\nbegingather\nmathbfA = fracmuDelta x^2 beginbmatrix\n-2  1  0  0  0  cdots  0 \n1  -2  1  0  0  cdots  0 \n0  1  -2  1  0  cdots  0 \n0  0  1  -2  1  cdots  0 \n0  0  0  1  -2  ddots  vdots \nvdots  vdots  vdots  vdots  ddots  ddots  1 \n0  0  0  0  0  1  -2\nendbmatrix\nendgather\n\nSuppose we are using a Dirichlet boundary condition of \n\nu(0t) = g(t) qquad u(Lt) = h(t)\n\nfor our model, then for the initial and last states we can see that (n-1)-th and (n+1)-th elements are missing, respectively. Thus, we compliment these missing elements for the boundary conditions using the control/input matrix. The boundary conditions can be incorporated by\n\nbegingather\nB = fracmuDelta x^2beginbmatrix\nu_0^k  0  0  0  vdots  vdots  0  0  0  u_N+1^k\nendbmatrix\nendgather\n\nThen we arrive at a N-dimensional linear time-invariant (LTI) system:\n\ndotmathbfu(t) = mathbfAmathbfu(t) + mathbfBmathbfw(t)\n\nwhere mathbfuinmathbbR^N is the state vector and mathbfw= g(t)h(t)^topinmathbbR^2 is the input vector.\n\n!!! tip Important     In finite difference approach, it is important to first do the spatial discretization of the system, and then develop the numerical integration scheme. Treating them separately will make your life easier...\n\nWe then consider the numerical integration scheme. For our numerical integration we can consider three approaches\n\nForward Euler\nBackward Euler\nCrank-Nicolson\n\nWe omit the details of each scheme (assuming you can google that). However, if you were to implement the forward Euler scheme, the integration step would be as follows\n\nbegingather*\nfracmathbfu(t_k+1) - mathbfu(t_k)Delta t = mathbfAmathbfu(t_k) + mathbfBmathbfw(t_k) \nmathbfu(t_k+1) = (mathbfI + Delta t mathbfA)mathbfu(t_k) + Delta t mathbfBmathbfw(t_k)\nendgather*\n\nThe backward Euler would be \n\nbegingather*\nfracmathbfu(t_k+1) - mathbfu(t_k)Delta t = mathbfAmathbfu(t_k+1) + mathbfBmathbfw(t_k) \nmathbfu(t_k+1) = (mathbfI - Delta t mathbfA)^-1leftmathbfu(t_k) + Delta t mathbfBmathbfw(t_k)right\nendgather*\n\nand Crank-Nicolson would be\n\nbegingather*\nfracmathbfu(t_k+1) - mathbfu(t_k)Delta t = frac12mathbfAleftmathbfu(t_k+1)+mathbfu(t_k)right + frac12mathbfBleftmathbfw(t_k+1)+mathbfw(t_k)right \nmathbfu(t_k+1) = left(mathbfI - fracDelta t2 mathbfAright)^-1leftleft(mathbfI+fracDelta t2mathbfAright)mathbfu(t_k) + fracDelta t2mathbfBleft(mathbfw(t_k+1)+mathbfw(t_k)right)right\nendgather*\n\nAnd this completes the finite difference model for the 1D heat equation. You can follow the same procedure for the periodic, Neumann, mixed, and other boundary conditions, which I will leave as an exercise for you.","category":"section"},{"location":"1D/heat1d/#Example","page":"1D Heat","title":"Example","text":"The example below uses the settings from [1].\n\nusing CairoMakie\nusing LinearAlgebra\nusing PolynomialModelReductionDataset: Heat1DModel\n\n# Setup\nNx = 2^7; dt = 1e-3\nheat1d = Heat1DModel(\n    spatial_domain=(0.0, 1.0), time_domain=(0.0, 1.0), \n    Δx=1/Nx, Δt=dt, diffusion_coeffs=0.1\n)\nUbc = ones(heat1d.time_dim) # boundary condition\n\n# Model operators\nA, B = heat1d.finite_diff_model(heat1d, heat1d.diffusion_coeffs; same_on_both_ends=true)\n\n# Integrate\nU = heat1d.integrate_model(\n    heat1d.tspan, heat1d.IC, Ubc; linear_matrix=A, control_matrix=B,\n    system_input=true, integrator_type=:BackwardEuler\n)\n\n# Surface plot\nfig1, _, sf = CairoMakie.surface(heat1d.xspan, heat1d.tspan, U, \n    axis=(type=Axis3, xlabel=L\"x\", ylabel=L\"t\", zlabel=L\"u(x,t)\"))\nCairoMakie.Colorbar(fig1[1, 2], sf)\nfig1\n\n# Flow field\nfig2, ax, hm = CairoMakie.heatmap(heat1d.xspan, heat1d.tspan, U)\nax.xlabel = L\"x\"\nax.ylabel = L\"t\"\nCairoMakie.Colorbar(fig2[1, 2], hm)\nfig2","category":"section"},{"location":"1D/heat1d/#API","page":"1D Heat","title":"API","text":"All models are a subset of AbstractModel","category":"section"},{"location":"1D/heat1d/#PolynomialModelReductionDataset.AbstractModel","page":"1D Heat","title":"PolynomialModelReductionDataset.AbstractModel","text":"AbstractModel\n\nAbstract type for the model.\n\n\n\n\n\n","category":"type"},{"location":"1D/heat1d/#PolynomialModelReductionDataset.Heat1D.Heat1DModel","page":"1D Heat","title":"PolynomialModelReductionDataset.Heat1D.Heat1DModel","text":"mutable struct Heat1DModel <: AbstractModel\n\n1 Dimensional Heat Equation Model\n\nfracpartial upartial t = mufracpartial^2 upartial x^2\n\nFields\n\nspatial_domain::Tuple{Real,Real}: spatial domain\ntime_domain::Tuple{Real,Real}: temporal domain\nparam_domain::Tuple{Real,Real}: parameter domain\nΔx::Real: spatial grid size\nΔt::Real: temporal step size\nBC::Symbol: boundary condition\nIC::Array{Float64}: initial condition\nxspan::Vector{Float64}: spatial grid points\ntspan::Vector{Float64}: temporal points\ndiffusion_coeffs::Union{Real,AbstractArray{<:Real}}: parameter vector\nspatial_dim::Int64: spatial dimension\ntime_dim::Int64: temporal dimension\nparam_dim::Int64: parameter dimension\nfinite_diff_model::Function: model using Finite Difference\nintegrate_model::Function: model integration\n\n\n\n\n\n","category":"type"},{"location":"1D/heat1d/#PolynomialModelReductionDataset.Heat1D","page":"1D Heat","title":"PolynomialModelReductionDataset.Heat1D","text":"1 Dimensional Heat Equation Model\n\n\n\n\n\n","category":"module"},{"location":"1D/heat1d/#PolynomialModelReductionDataset.Heat1D.finite_diff_dirichlet_model-Tuple{Real, Real, Real}","page":"1D Heat","title":"PolynomialModelReductionDataset.Heat1D.finite_diff_dirichlet_model","text":"finite_diff_dirichlet_model(N, Δx, μ; same_on_both_ends)\n\n\nFinite Difference Model for 1D Heat Equation with Dirichlet boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"1D/heat1d/#PolynomialModelReductionDataset.Heat1D.finite_diff_mixed_model-Tuple{Real, Real, Real}","page":"1D Heat","title":"PolynomialModelReductionDataset.Heat1D.finite_diff_mixed_model","text":"finite_diff_mixed_model(N, Δx, μ; order)\n\n\nFinite difference model for the 1D Heat Equation with Mixed boundary condition. The mixed boundary condition is a combination of Neumann and Dirichlet boundary conditions. The left boundary is Neumann and the right boundary is Dirichlet when order is set to [\"neumann\", \"dirichlet\"]. If order is set to [\"dirichlet\", \"neumann\"], then the left boundary is Dirichlet and the right boundary is Neumann.\n\n\n\n\n\n","category":"method"},{"location":"1D/heat1d/#PolynomialModelReductionDataset.Heat1D.finite_diff_model-Tuple{PolynomialModelReductionDataset.Heat1D.Heat1DModel, Real}","page":"1D Heat","title":"PolynomialModelReductionDataset.Heat1D.finite_diff_model","text":"finite_diff_model(model, μ; kwargs...)\n\n\nFinite Difference Model for 1D Heat Equation\n\nArguments\n\nmodel::Heat1DModel: 1D heat equation model\nμ::Real: diffusion coefficient\n\nReturns\n\noperators\n\n\n\n\n\n","category":"method"},{"location":"1D/heat1d/#PolynomialModelReductionDataset.Heat1D.finite_diff_neumann_model-Tuple{Real, Real, Real}","page":"1D Heat","title":"PolynomialModelReductionDataset.Heat1D.finite_diff_neumann_model","text":"finite_diff_neumann_model(N, Δx, μ)\n\n\nFinite difference model for the 1D Heat Equation with Neumann boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"1D/heat1d/#PolynomialModelReductionDataset.Heat1D.finite_diff_periodic_model-Tuple{Real, Real, Real}","page":"1D Heat","title":"PolynomialModelReductionDataset.Heat1D.finite_diff_periodic_model","text":"finite_diff_periodic_model(N, Δx, μ)\n\n\nFinite Difference Model for 1D Heat Equation with periodic boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"1D/heat1d/#PolynomialModelReductionDataset.Heat1D.finite_diff_robin_model-Tuple{Real, Real, Real}","page":"1D Heat","title":"PolynomialModelReductionDataset.Heat1D.finite_diff_robin_model","text":"finite_diff_robin_model(N, Δx, μ; α, β)\n\n\nFinite difference model for the 1D Heat Equation with Robin boundary condition.  The Robin boundary condition is a generalization of the Neumann and Dirichlet  boundary conditions, where the boundary condition is a linear combination of the state and its derivative. That is,\n\nalpha u(0) + (1 - alpha) u(0) = g(t)\n\nThe weights α and β are used to adjust the boundary conditions at the left and right boundaries, respectively.\n\n\n\n\n\n","category":"method"},{"location":"1D/heat1d/#PolynomialModelReductionDataset.Heat1D.integrate_model-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractArray{T}}} where T<:Real","page":"1D Heat","title":"PolynomialModelReductionDataset.Heat1D.integrate_model","text":"integrate_model(tdata, u0; ...)\nintegrate_model(tdata, u0, input; kwargs...)\n\n\nIntegrate the 1D Heat Equation Model using 3 different methods:\n\nForward Euler\nBackward Euler\nCrank Nicolson\n\nArguments\n\ntdata::AbstractVector{T}: time data\nx0::AbstractVector{T}: initial condition\nu::AbstractArray{T}=[]: input data\n\nKeyword Arguments\n\nlinear_matrix::AbstractArray{T,2}: linear matrix\ncontrol_matrix::AbstractArray{T,2}: control matrix\nsystem_input::Bool=false: system input flag\nintegrator_type::Symbol=:ForwardEuler: integrator type\nsame_on_both_ends::Bool=true: same boundary (Dirichlet) condition on both ends\n\nReturns\n\nx::Array{T,2}: integrated model states\n\nNotes\n\nInput is assumed to be a matrix of size (spatial dimension x time dimension). You will receive a warning if the input is a tall vector/column vector.\noperators should be in the order of [A, B] if system_input is true.\n\n\n\n\n\n","category":"method"},{"location":"1D/fisherkpp/#Fisher-KPP-Equation","page":"Fisher-KPP Equation","title":"Fisher-KPP Equation","text":"","category":"section"},{"location":"1D/fisherkpp/#Overview","page":"Fisher-KPP Equation","title":"Overview","text":"The Fisher-KPP equation, also known as the Fisher equation or the Kolmogorov-Petrovsky-Piskunov equation, is a fundamental nonlinear partial differential equation (PDE) in mathematical biology. It models the spread of an advantageous gene in a population or, more generally, the propagation of a biological or chemical species. Independently introduced by Ronald Fisher in 1937 and by Kolmogorov, Petrovsky, and Piskunov (KPP) in the same year, it combines diffusion and logistic growth to describe wave-like phenomena in population dynamics.\n\nThe one-dimensional Fisher-KPP equation is given by:\n\nu_t = D u_xx + r u (1 - u)\n\nWhere:\n\nu(x t) is the density of the species or the frequency of an advantageous gene at position x and time t.\nD is the diffusion coefficient, representing spatial dispersal.\nr is the intrinsic growth rate of the population.","category":"section"},{"location":"1D/fisherkpp/#Key-Features","page":"Fisher-KPP Equation","title":"Key Features","text":"Reaction-Diffusion System: Combines local reactions (logistic growth) and spatial diffusion.\nNonlinearity: The term r u (1 - u) introduces nonlinearity, leading to complex dynamics like traveling waves.\nTraveling Wave Solutions: Admits solutions of the form u(x t) = U(x - c t), representing waves propagating at constant speed c.","category":"section"},{"location":"1D/fisherkpp/#Physical-Interpretation","page":"Fisher-KPP Equation","title":"Physical Interpretation","text":"Population Genetics: Models the spread of a beneficial gene through a spatially distributed population.\nEcology: Describes the invasion of a species into new territory.\nChemical Kinetics: Represents autocatalytic chemical reactions spreading through a medium.","category":"section"},{"location":"1D/fisherkpp/#Properties","page":"Fisher-KPP Equation","title":"Properties","text":"","category":"section"},{"location":"1D/fisherkpp/#Traveling-Wave-Solutions","page":"Fisher-KPP Equation","title":"Traveling Wave Solutions","text":"Seeking solutions of the form u(x t) = U(z) with z = x - c t, the equation becomes an ordinary differential equation (ODE):\n-c fracdUdz = D fracd^2 Udz^2 + r U (1 - U)\nBoundary conditions for invasion problems are:\nU(-infty) = 1 quad U(infty) = 0\nMinimum Wave Speed:\nThe minimum speed c_textmin at which traveling waves propagate is:\nc_textmin = 2 sqrtD r","category":"section"},{"location":"1D/fisherkpp/#Stability-and-Asymptotic-Behavior","page":"Fisher-KPP Equation","title":"Stability and Asymptotic Behavior","text":"Stability of Traveling Waves: Waves traveling at speeds c geq c_textmin are stable.\nAsymptotic Spread: The population front advances at speed c_textmin over long times.","category":"section"},{"location":"1D/fisherkpp/#Linearization-Near-Zero","page":"Fisher-KPP Equation","title":"Linearization Near Zero","text":"Near u = 0, the equation can be linearized:\nfracpartial upartial t approx D fracpartial^2 upartial x^2 + r u\nSolutions grow exponentially if u  0, leading to the invasion of the population.","category":"section"},{"location":"1D/fisherkpp/#Applications","page":"Fisher-KPP Equation","title":"Applications","text":"Population Dynamics: Modeling species invasion, range expansion, and the spread of epidemics.\nGenetics: Describing gene propagation in spatially structured populations.\nEcology and Conservation Biology: Understanding the impact of habitat fragmentation and corridors on species spread.\nChemical and Biological Waves: Studying flame propagation, neural activity, and reaction-diffusion systems.","category":"section"},{"location":"1D/fisherkpp/#Generalizations","page":"Fisher-KPP Equation","title":"Generalizations","text":"Higher Dimensions: Extension to two or three spatial dimensions:\nfracpartial upartial t = D nabla^2 u + r u (1 - u)\nHeterogeneous Media: Incorporating spatially varying parameters D(x) and r(x).\nTime-Delayed Reactions: Introducing delays in the reaction term to model maturation time.","category":"section"},{"location":"1D/fisherkpp/#Model","page":"Fisher-KPP Equation","title":"Model","text":"This equation is a quadratic model\n\ndotmathbfu(t) = mathbfAu(t) + mathbfF(mathbfu(t) oslash mathbfu(t)) + mathbfBw(t)","category":"section"},{"location":"1D/fisherkpp/#Numerical-Integration","page":"Fisher-KPP Equation","title":"Numerical Integration","text":"For the numerical integration we consider two methods:\n\nSemi-Implicit Crank-Nicolson (SICN)\nCrank-Nicolson Adam-Bashforth (CNAB)\n\nThe time stepping for each methods are \n\nSICN:\n\nmathbfu(t_k+1) = left(mathbfI-fracDelta t2mathbfAright)^-1 left left( mathbfI + fracDelta t2mathbfA right)mathbfu(t_k) + Delta tmathbfFmathbfu^langle 2rangle(t_k) + fracDelta t2 mathbfBleft mathbfw(t_k+1) + mathbfw(t_k) rightright\n\nCNAB:\n\nIf k=1\n\nmathbfu(t_k+1) = left(mathbfI-fracDelta t2mathbfAright)^-1 left left( mathbfI + fracDelta t2mathbfA right)mathbfu(t_k) + Delta tmathbfFmathbfu^langle 2rangle(t_k) + fracDelta t2 mathbfBleft mathbfw(t_k+1) + mathbfw(t_k) rightright\n\nIf kgeq 2\n\nmathbfu(t_k+1) = left(mathbfI-fracDelta t2mathbfAright)^-1 left left( mathbfI + fracDelta t2mathbfA right)mathbfu(t_k) + frac3Delta t2mathbfFmathbfu^langle 2rangle(t_k) - fracDelta t2mathbfFmathbfu^langle 2rangle(t_k-1) + fracDelta t2 mathbfBleft mathbfw(t_k+1) + mathbfw(t_k) rightright\n\nwhere mathbfu^langle 2 rangle=mathbfu oslash mathbfu.","category":"section"},{"location":"1D/fisherkpp/#Example","page":"Fisher-KPP Equation","title":"Example","text":"using CairoMakie\nusing LinearAlgebra\nusing PolynomialModelReductionDataset: FisherKPPModel\n\n# Setup\nΩ = (0, 3)  # Choose integers\nT = (0.0, 5.0)\nNx = 2^8\ndt = 1e-3\nfisherkpp = FisherKPPModel(\n    spatial_domain=Ω, time_domain=T, Δx=((Ω[2]-Ω[1]) + 1/Nx)/Nx, Δt=dt, \n    params=Dict(:D => 1.0, :r => 1.0), BC=:dirichlet\n)\nDS = 10\n\n# Create piecewise IC\na, b, c = (sort ∘ rand)(1:fisherkpp.spatial_dim, 3)\nseg1 = ones(length(fisherkpp.xspan[1:a]))\nseg2 = zeros(length(fisherkpp.xspan[a+1:b]))\nseg3 = rand(0.1:0.1:0.5) * ones(length(fisherkpp.xspan[b+1:c]))\nseg4 = zeros(length(fisherkpp.xspan[c+1:end]))\nfisherkpp.IC = [seg1; seg2; seg3; seg4]\n\n# Boundary conditions\nUbc1 = ones(1,fisherkpp.time_dim)\nUbc2 = zeros(1,fisherkpp.time_dim)\nUbc = [Ubc1; Ubc2]\n\n# Operators\nA, F, B = fisherkpp.finite_diff_model(fisherkpp, fisherkpp.params)\n\n# Integrate\nU = fisherkpp.integrate_model(\n    fisherkpp.tspan, fisherkpp.IC, Ubc; \n    linear_matrix=A, quadratic_matrix=F, control_matrix=B,\n    system_input=true, integrator_type=:CNAB,\n)\n\n# Surface plot\nfig3, _, sf = CairoMakie.surface(fisherkpp.xspan, fisherkpp.tspan[1:DS:end], U[:, 1:DS:end], \n    axis=(type=Axis3, xlabel=L\"x\", ylabel=L\"t\", zlabel=L\"u(x,t)\"))\nCairoMakie.Colorbar(fig3[1, 2], sf)\nfig3\n\n# Flow field\nfig4, ax, hm = CairoMakie.heatmap(fisherkpp.xspan, fisherkpp.tspan[1:DS:end], U[:, 1:DS:end])\nax.xlabel = L\"x\"\nax.ylabel = L\"t\"\nCairoMakie.Colorbar(fig4[1, 2], hm)\nfig4","category":"section"},{"location":"1D/fisherkpp/#API","page":"Fisher-KPP Equation","title":"API","text":"","category":"section"},{"location":"1D/fisherkpp/#PolynomialModelReductionDataset.FisherKPP.FisherKPPModel","page":"Fisher-KPP Equation","title":"PolynomialModelReductionDataset.FisherKPP.FisherKPPModel","text":"mutable struct FisherKPPModel <: AbstractModel\n\nFisher Kolmogorov-Petrovsky-Piskunov equation (Fisher-KPP) model is a reaction-diffusion equation or logistic diffusion process in population dynamics. The model is given by the following PDE: \n\nfracpartial upartial t =  Dfracpartial^2 upartial x^2 + ru(1-u)\n\nwhere u is the state variable, D is the diffusion coefficient, and r is the growth rate.\n\nFields\n\nspatial_domain::Tuple{Real,Real}: spatial domain\ntime_domain::Tuple{Real,Real}: temporal domain\ndiffusion_coeff_domain::Tuple{Real,Real}: parameter domain (diffusion coeff)\ngrowth_rate_domain::Tuple{Real,Real}: parameter domain (growth rate)\nΔx::Real: spatial grid size\nΔt::Real: temporal step size\nxspan::Vector{<:Real}: spatial grid points\ntspan::Vector{<:Real}: temporal points\nspatial_dim::Int: spatial dimension\ntime_dim::Int: temporal dimension\ndiffusion_coeffs::Union{AbstractArray{<:Real},Real}: diffusion coefficient\ngrowth_rates::Union{AbstractArray{<:Real},Real}: growth rate\nparam_dim::Dict{Symbol,<:Int}: parameter dimension\nIC::AbstractArray{<:Real}: initial condition\nBC::Symbol: boundary condition\nfinite_diff_model::Function: model using Finite Difference\nintegrate_model::Function: integrator using Crank-Nicholson (linear) Explicit (nonlinear) method\n\n\n\n\n\n","category":"type"},{"location":"1D/fisherkpp/#PolynomialModelReductionDataset.FisherKPP","page":"Fisher-KPP Equation","title":"PolynomialModelReductionDataset.FisherKPP","text":"Fisher Kolmogorov-Petrovsky-Piskunov equation (Fisher-KPP) model\n\n\n\n\n\n","category":"module"},{"location":"1D/fisherkpp/#PolynomialModelReductionDataset.FisherKPP.finite_diff_dirichlet_model-Tuple{Real, Real, Dict}","page":"Fisher-KPP Equation","title":"PolynomialModelReductionDataset.FisherKPP.finite_diff_dirichlet_model","text":"finite_diff_dirichlet_model(N, Δx, params)\n\n\nCreate the matrices A (linear operator), F (quadratic operator), and B (control operator) for the Fisher-KPP model with Dirichlet boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"1D/fisherkpp/#PolynomialModelReductionDataset.FisherKPP.finite_diff_mixed_model-Tuple{Real, Real, Dict}","page":"Fisher-KPP Equation","title":"PolynomialModelReductionDataset.FisherKPP.finite_diff_mixed_model","text":"finite_diff_mixed_model(N, Δx, params)\n\n\nCreate the matrices A (linear operator), F (quadratic operator), and B (control operator) for the Fisher-KPP model with mixed boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"1D/fisherkpp/#PolynomialModelReductionDataset.FisherKPP.finite_diff_model-Tuple{PolynomialModelReductionDataset.FisherKPP.FisherKPPModel, Dict}","page":"Fisher-KPP Equation","title":"PolynomialModelReductionDataset.FisherKPP.finite_diff_model","text":"finite_diff_model(model, params)\n\n\nCreate the matrices A (linear operator) and F (quadratic operator) for the Fisher-KPP model. For different boundary conditions, the matrices are created differently.\n\nArguments\n\nmodel::FisherKPPModel: Fisher-KPP model\nparams::Dict: parameters for the model\n\n\n\n\n\n","category":"method"},{"location":"1D/fisherkpp/#PolynomialModelReductionDataset.FisherKPP.finite_diff_periodic_model-Tuple{Real, Real, Dict}","page":"Fisher-KPP Equation","title":"PolynomialModelReductionDataset.FisherKPP.finite_diff_periodic_model","text":"finite_diff_periodic_model(N, Δx, params)\n\n\nCreate the matrices A (linear operator) and F (quadratic operator) for the Fisher-KPP model with periodic boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"1D/fisherkpp/#PolynomialModelReductionDataset.FisherKPP.integrate_model-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractArray{T}}} where T<:Real","page":"Fisher-KPP Equation","title":"PolynomialModelReductionDataset.FisherKPP.integrate_model","text":"integrate_model(tdata, u0; ...)\nintegrate_model(tdata, u0, input; kwargs...)\n\n\nIntegrate the Fisher-KPP model using the Semi-Implicit Crank-Nicholson (SICN) method and Crank-Nicholson Adam-Bashforth (CNAB) method.\n\nArguments\n\ntdata::AbstractArray{T}: time data\nu0::AbstractArray{T}: initial condition\ninput::AbstractArray{T}=[]: input data\n\nKeyword Arguments\n\nlinear_matrix::AbstractArray{T,2}: linear matrix\nquadratic_matrix::AbstractArray{T,2}: quadratic matrix\ncontrol_matrix::AbstractArray{T,2}: control matrix\nsystem_input::Bool=false: system input flag\nconst_stepsize::Bool=false: constant step size flag\nu2_jm1::AbstractArray{T}=[]: previous state\nintegrator_type::Symbol=:CNAB: integrator type\n\nReturns\n\nu::Array{T,2}: integrated model states\n\nNotes\n\nThe integrator_type can be either :SICN for Semi-Implicit Crank-Nicolson or :CNAB for Crank-Nicolson Adam-Bashforth\nThe system_input flag is set to false if no input is provided\nThe const_stepsize flag is set to false by default\nThe u2_jm1 is the previous state of the system\n\n\n\n\n\n","category":"method"},{"location":"1D/fisherkpp/#PolynomialModelReductionDataset.FisherKPP.integrate_model_with_control_CNAB-Tuple{Any, Any, Any}","page":"Fisher-KPP Equation","title":"PolynomialModelReductionDataset.FisherKPP.integrate_model_with_control_CNAB","text":"integrate_model_with_control_CNAB(\n    tdata,\n    u0,\n    input;\n    linear_matrix,\n    quadratic_matrix,\n    control_matrix,\n    const_stepsize,\n    u2_jm1\n)\n\n\nIntegrate the Fisher-KPP model using the Crank-Nicholson (linear) Adam-Bashforth (nonlinear) method (CNAB) with control.\n\n\n\n\n\n","category":"method"},{"location":"1D/fisherkpp/#PolynomialModelReductionDataset.FisherKPP.integrate_model_with_control_SICN-Tuple{Any, Any, Any}","page":"Fisher-KPP Equation","title":"PolynomialModelReductionDataset.FisherKPP.integrate_model_with_control_SICN","text":"integrate_model_with_control_SICN(\n    tdata,\n    u0,\n    input;\n    linear_matrix,\n    quadratic_matrix,\n    control_matrix,\n    const_stepsize\n)\n\n\nIntegrate the Fisher-KPP model using the Crank-Nicholson (linear) Explicit (nonlinear) method. Or Semi-Implicit Crank-Nicholson (SICN) method with control input\n\n\n\n\n\n","category":"method"},{"location":"1D/fisherkpp/#PolynomialModelReductionDataset.FisherKPP.integrate_model_without_control_CNAB-Tuple{Any, Any}","page":"Fisher-KPP Equation","title":"PolynomialModelReductionDataset.FisherKPP.integrate_model_without_control_CNAB","text":"integrate_model_without_control_CNAB(\n    tdata,\n    u0;\n    linear_matrix,\n    quadratic_matrix,\n    const_stepsize,\n    u2_jm1\n)\n\n\nIntegrate the Chafee-Infante model using the Crank-Nicholson (linear) Adam-Bashforth (nonlinear) method (CNAB) without control.\n\n\n\n\n\n","category":"method"},{"location":"1D/fisherkpp/#PolynomialModelReductionDataset.FisherKPP.integrate_model_without_control_SICN-Tuple{Any, Any}","page":"Fisher-KPP Equation","title":"PolynomialModelReductionDataset.FisherKPP.integrate_model_without_control_SICN","text":"integrate_model_without_control_SICN(\n    tdata,\n    u0;\n    linear_matrix,\n    quadratic_matrix,\n    const_stepsize\n)\n\n\nIntegrate the Fisher-KPP model using the Crank-Nicholson (linear) Explicit (nonlinear) method with control. Or Semi-Implicit Crank-Nicholson (SICN) method.\n\n\n\n\n\n","category":"method"},{"location":"1D/mKdVB/#Modified-Korteweg-de-Vries-Burgers-Equation","page":"Modified Korteweg-de Vries-Burgers Equation","title":"Modified Korteweg-de Vries-Burgers Equation","text":"","category":"section"},{"location":"1D/mKdVB/#Overview","page":"Modified Korteweg-de Vries-Burgers Equation","title":"Overview","text":"This is a modified version of the mKdV equation where we included the diffusion term u_xx. The equation is defined by\n\nu_t + alpha u_xxx + beta u^2u_x + gamma u_xx = 0","category":"section"},{"location":"1D/mKdVB/#Model","page":"Modified Korteweg-de Vries-Burgers Equation","title":"Model","text":"The Modified Korteweg-de Vries-Burgers equation becomes a cubic model:\n\ndotmathbfu(t) = mathbfAu(t) + mathbfG(mathbfu(t) otimes mathbfu(t) otimes mathbfu(t)) + mathbfBw(t)\n\nor \n\ndotmathbfu(t) = mathbfAu(t) + mathbfE(mathbfu(t) oslash mathbfu(t) oslash mathbfu(t)) + mathbfBw(t)\n\nwhere\n\nmathbfuinmathbbR^N: the state vector\nmathbfwinmathbbR^m: the input vector\nmathbfAinmathbbR^Ntimes N: the linear state matrix\nmathbfGinmathbbR^Ntimes N^3: the cubic state matrix with redundancy\nmathbfEinmathbbR^Ntimes N(N+1)(N+2)6: the cubic state matrix without redundancy\nmathbfBinmathbbR^Ntimes m: the control input matrix","category":"section"},{"location":"1D/mKdVB/#Numerical-Integration","page":"Modified Korteweg-de Vries-Burgers Equation","title":"Numerical Integration","text":"For the numerical integration we consider two methods:\n\nSemi-Implicit Euler (SIE)\nCrank-Nicolson Adam-Bashforth (CNAB)\n\nFor the exact expressions of the time-stepping check Allen-Cahn equation.","category":"section"},{"location":"1D/mKdVB/#Example","page":"Modified Korteweg-de Vries-Burgers Equation","title":"Example","text":"using CairoMakie\nusing LinearAlgebra\nusing PolynomialModelReductionDataset: ModifiedKortewegDeVriesBurgersModel\n\n# Setup\nΩ = (0.0, 3.0)\nNx = 2^8; dt = 1e-3\nmKdV = ModifiedKortewegDeVriesBurgersModel(\n    spatial_domain=Ω, time_domain=(0.0, 3.0), Δx=(Ω[2] + 1/Nx)/Nx, Δt=dt,\n    params=Dict(:a => 1, :b => 3, :c=> 0.1), BC=:dirichlet,\n)\nDS = 100\nmKdV.IC = 2 * cos.(2π * mKdV.xspan / (Ω[2] - Ω[1])) # + 0.5 * cos.(4π * mKdV.xspan / (Ω[2] - Ω[1]))\nUbc1 = 0.5ones(1,mKdV.time_dim)\nUbc2 = -0.5ones(1,mKdV.time_dim)\nUbc = [Ubc1; Ubc2]\n\n# Operators\nA, E, B = mKdV.finite_diff_model(mKdV, mKdV.params)\n\n# Integrate\nU = mKdV.integrate_model(\n    mKdV.tspan, mKdV.IC, Ubc; \n    linear_matrix=A, cubic_matrix=E, control_matrix=B,\n    system_input=true, integrator_type=:CNAB,\n)\n\n# Surface plot\nfig3, _, sf = CairoMakie.surface(mKdV.xspan, mKdV.tspan[1:DS:end], U[:, 1:DS:end], \n    axis=(type=Axis3, xlabel=L\"x\", ylabel=L\"t\", zlabel=L\"u(x,t)\"))\nCairoMakie.Colorbar(fig3[1, 2], sf)\nfig3\n\n# Flow field\nfig4, ax, hm = CairoMakie.heatmap(mKdV.xspan, mKdV.tspan[1:DS:end], U[:, 1:DS:end])\nax.xlabel = L\"x\"\nax.ylabel = L\"t\"\nCairoMakie.Colorbar(fig4[1, 2], hm)\nfig4\n","category":"section"},{"location":"1D/mKdVB/#API","page":"Modified Korteweg-de Vries-Burgers Equation","title":"API","text":"","category":"section"},{"location":"1D/mKdVB/#PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers.ModifiedKortewegDeVriesBurgersModel","page":"Modified Korteweg-de Vries-Burgers Equation","title":"PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers.ModifiedKortewegDeVriesBurgersModel","text":"mutable struct ModifiedKortewegDeVriesBurgersModel <: AbstractModel\n\nModified Korteweg-de Vries-Burgers equation model\n\nfracpartial upartial t = -alphafracpartial^3 upartial x^3 - beta u^2fracpartial upartial x + gammafracpartial^2 upartial x^2\n\nFields\n\nspatial_domain::Tuple{Real,Real}: spatial domain\ntime_domain::Tuple{Real,Real}: temporal domain\nparam_domain::Tuple{Real,Real}: parameter domain\nΔx::Real: spatial grid size\nΔt::Real: temporal step size\nBC::Symbol: boundary condition\nIC::Array{Float64}: initial condition\nxspan::Vector{Float64}: spatial grid points\ntspan::Vector{Float64}: temporal points\nspatial_dim::Int64: spatial dimension\ntime_dim::Int64: temporal dimension\nparams::Union{Real,AbstractArray{<:Real}}: parameter vector\nparam_dim::Int64: parameter dimension\nfinite_diff_model::Function: model using Finite Difference\nintegrate_model::Function: model integration\n\n\n\n\n\n","category":"type"},{"location":"1D/mKdVB/#PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers","page":"Modified Korteweg-de Vries-Burgers Equation","title":"PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers","text":"Modified Korteweg-de Vries-Burgers (mKdVB) equation\n\n\n\n\n\n","category":"module"},{"location":"1D/mKdVB/#PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers.finite_diff_dirichlet_model-Tuple{Real, Real, Real, Dict}","page":"Modified Korteweg-de Vries-Burgers Equation","title":"PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers.finite_diff_dirichlet_model","text":"finite_diff_dirichlet_model(N, Δx, Δt, params)\n\n\nFinite Difference Model for the Gardner equation with Dirichlet boundary condition (Non-conservative).\n\n\n\n\n\n","category":"method"},{"location":"1D/mKdVB/#PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers.finite_diff_model-Tuple{PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers.ModifiedKortewegDeVriesBurgersModel, Dict}","page":"Modified Korteweg-de Vries-Burgers Equation","title":"PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers.finite_diff_model","text":"finite_diff_model(model, params)\n\n\nFinite Difference Model for mKdV equation\n\nArguments\n\nmodel::ModifiedKortewegDeVriesBurgersModel: mKdV model\nparams::Real: params including a, b, c\n\nReturns\n\noperators\n\n\n\n\n\n","category":"method"},{"location":"1D/mKdVB/#PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers.finite_diff_periodic_model-Tuple{Real, Real, Dict}","page":"Modified Korteweg-de Vries-Burgers Equation","title":"PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers.finite_diff_periodic_model","text":"finite_diff_periodic_model(N, Δx, params)\n\n\nGenerate A and E matrices for the Gardner equation for periodic boundary condition (Non-conservative).\n\n\n\n\n\n","category":"method"},{"location":"1D/mKdVB/#PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers.integrate_model-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractArray{T}}} where T<:Real","page":"Modified Korteweg-de Vries-Burgers Equation","title":"PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers.integrate_model","text":"integrate_model(tdata, u0; ...)\nintegrate_model(tdata, u0, input; kwargs...)\n\n\nIntegrate the mKdVB model using Semi-Implicit Euler (SIE) or Crank-Nicolson Adam-Bashforth (CNAB) scheme with or without control\n\nArguments\n\ntdata::AbstractArray{T}: time data\nu0::AbstractArray{T}: initial condition\ninput::AbstractArray{T}=[]: input data\n\nKeyword Arguments\n\nlinear_matrix::AbstractArray{T,2}: linear matrix\ncubic_matrix::AbstractArray{T,2}: cubic matrix\ncontrol_matrix::AbstractArray{T,2}: control matrix\nsystem_input::Bool=false: system input flag\nconst_stepsize::Bool=false: constant step size flag\nu3_jm1::AbstractArray{T,2}: cubic matrix at j-1\nintegrator_type::Symbol=:CNAB: integrator type\n\nReturns\n\nu::Array{T,2}: integrated model states\n\nNotes\n\nIf system_input is true, then control_matrix is required\nIf const_stepsize is true, then the time step size is assumed to be constant\nIf u3_jm1 is provided, then the cubic matrix at j-1 is used in the integration\nThe integrator type can be either Semi-Implicit Euler (SIE) or Crank-Nicolson Adam-Bashforth (CNAB)\n\n\n\n\n\n","category":"method"},{"location":"1D/mKdVB/#PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers.integrate_model_with_control_CNAB-Tuple{Any, Any, Any}","page":"Modified Korteweg-de Vries-Burgers Equation","title":"PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers.integrate_model_with_control_CNAB","text":"integrate_model_with_control_CNAB(\n    tdata,\n    u0,\n    input;\n    linear_matrix,\n    cubic_matrix,\n    control_matrix,\n    const_stepsize,\n    u3_jm1\n)\n\n\nCrank-Nicolson Adam-Bashforth (CNAB) scheme with control\n\n\n\n\n\n","category":"method"},{"location":"1D/mKdVB/#PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers.integrate_model_with_control_SIE-Tuple{Any, Any, Any}","page":"Modified Korteweg-de Vries-Burgers Equation","title":"PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers.integrate_model_with_control_SIE","text":"integrate_model_with_control_SIE(\n    tdata,\n    u0,\n    input;\n    linear_matrix,\n    cubic_matrix,\n    control_matrix\n)\n\n\nSemi-Implicit Euler (SIE) scheme with control\n\n\n\n\n\n","category":"method"},{"location":"1D/mKdVB/#PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers.integrate_model_without_control_CNAB-Tuple{Any, Any}","page":"Modified Korteweg-de Vries-Burgers Equation","title":"PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers.integrate_model_without_control_CNAB","text":"integrate_model_without_control_CNAB(\n    tdata,\n    u0;\n    linear_matrix,\n    cubic_matrix,\n    const_stepsize,\n    u3_jm1\n)\n\n\nCrank-Nicolson Adam-Bashforth (CNAB) scheme without control\n\n\n\n\n\n","category":"method"},{"location":"1D/mKdVB/#PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers.integrate_model_without_control_SIE-Tuple{Any, Any}","page":"Modified Korteweg-de Vries-Burgers Equation","title":"PolynomialModelReductionDataset.ModifiedKortewegDeVriesBurgers.integrate_model_without_control_SIE","text":"integrate_model_without_control_SIE(\n    tdata,\n    u0;\n    linear_matrix,\n    cubic_matrix\n)\n\n\nSemi-Implicit Euler (SIE) scheme without control\n\n\n\n\n\n","category":"method"},{"location":"2D/allencahn2d/#2D-Allen-Cahn-Equation","page":"2D Allen-Cahn Equation","title":"2D Allen-Cahn Equation","text":"","category":"section"},{"location":"2D/allencahn2d/#Overview","page":"2D Allen-Cahn Equation","title":"Overview","text":"The Allen-Cahn equation is a reaction-diffusion equation that was originally introduced to describe phase separation in multi-component alloy systems. It models the evolution of a non-conserved order parameter and is widely used to study interface dynamics, pattern formation, and phase transitions.\n\nThe 2D Allen-Cahn equation is given by:\n\nfracpartial upartial t = muleft(fracpartial^2 upartial x^2 + fracpartial^2 upartial y^2right) - epsilon(u^3 - u)\n\nwhere:\n\nu(x y t) is the order parameter (e.g., concentration or phase indicator)\nmu is the diffusion coefficient (also called mobility parameter)\nepsilon is the nonlinear coefficient that determines the interface width\nx y are spatial coordinates\nt is time\n\nThe cubic nonlinearity -epsilon(u^3 - u) creates a double-well potential that drives the system toward two stable phases (typically represented by u approx pm 1), while the diffusion term smooths interfaces between these phases.","category":"section"},{"location":"2D/allencahn2d/#Model","page":"2D Allen-Cahn Equation","title":"Model","text":"For our numerical implementation, we discretize the PDE and separate the system into linear and nonlinear components:\n\ndotmathbfu(t) = mathbfAmathbfu(t) + mathbfEmathbfu^langle 3rangle(t) + mathbfBmathbfw(t)\n\nwhere:\n\nmathbfA is the linear operator (containing diffusion and linear reaction terms)\nmathbfE is the cubic operator (for the u^3 term)\nmathbfu^langle 3rangle represents the cubic states (non-redundant)\nmathbfB is the control/input matrix (for boundary conditions)\nmathbfw(t) represents boundary inputs (if applicable)\n\nnote: Note\nBoth periodic and Dirichlet boundary conditions are implemented for the 2D Allen-Cahn equation.","category":"section"},{"location":"2D/allencahn2d/#Numerical-Integration","page":"2D Allen-Cahn Equation","title":"Numerical Integration","text":"We integrate the Allen-Cahn model using semi-implicit time-stepping schemes that treat the linear diffusion term implicitly and the nonlinear term explicitly. Two methods are available:","category":"section"},{"location":"2D/allencahn2d/#Semi-Implicit-Crank-Nicolson-(SICN)","page":"2D Allen-Cahn Equation","title":"Semi-Implicit Crank-Nicolson (SICN)","text":"fracmathbfu(t_k+1) - mathbfu(t_k)Delta t = mathbfAleft(fracmathbfu(t_k+1) + mathbfu(t_k)2right) + mathbfEleft(mathbfu(t_k)right)^langle 3rangle","category":"section"},{"location":"2D/allencahn2d/#Crank-Nicolson-Adams-Bashforth-(CNAB)","page":"2D Allen-Cahn Equation","title":"Crank-Nicolson Adams-Bashforth (CNAB)","text":"fracmathbfu(t_k+1) - mathbfu(t_k)Delta t = mathbfAleft(fracmathbfu(t_k+1) + mathbfu(t_k)2right) + frac32mathbfEleft(mathbfu(t_k)right)^langle 3rangle - frac12mathbfEleft(mathbfu(t_k-1)right)^langle 3rangle\n\nBoth methods provide second-order accuracy in time and maintain good stability properties for stiff systems.","category":"section"},{"location":"2D/allencahn2d/#Finite-Difference-Model","page":"2D Allen-Cahn Equation","title":"Finite Difference Model","text":"The spatial discretization follows the same approach as the 2D Heat equation for the diffusion terms. The domain is discretized with N_x and N_y grid points in the x and y directions respectively.\n\nFor periodic boundary conditions, we construct circulant matrices for each direction:\n\nmathbfA_x in mathbbR^N_x times N_x quad mathbfA_y in mathbbR^N_y times N_y\n\nThe 2D linear operator is then constructed using the Kronecker sum:\n\nmathbfA = mathbfA_y otimes mathbfI_N_x + mathbfI_N_y otimes mathbfA_x\n\nwhere mathbfI denotes the identity matrix.\n\nThe cubic operator mathbfE is constructed to map the non-redundant cubic monomials to the state derivatives. For a system with N_total = N_x times N_y degrees of freedom, the cubic monomial space has dimension S = N_total(N_total+1)(N_total+2)6.\n\nFor Dirichlet boundary conditions, we additionally construct a control matrix mathbfB that applies boundary values at the appropriate grid points (left, right, bottom, top boundaries).","category":"section"},{"location":"2D/allencahn2d/#Example-Periodic-BC","page":"2D Allen-Cahn Equation","title":"Example - Periodic BC","text":"In this example, we demonstrate phase separation from a star-shaped initial condition with periodic boundary conditions.\n\nusing CairoMakie\nusing LinearAlgebra\nusing PolynomialModelReductionDataset: AllenCahn2DModel\nusing UniqueKronecker: invec\n\n# Setup\nΩ = ((0.0, 1.0), (0.0, 1.0))\nNx = 2^5\nNy = 2^5\nallencahn2d = AllenCahn2DModel(\n    spatial_domain=Ω, time_domain=(0,1.0), \n    Δx=(Ω[1][2] + 1/Nx)/Nx, Δy=(Ω[2][2] + 1/Ny)/Ny, Δt=1e-3,\n    params=Dict(:μ => 1e-2, :ϵ => 1.0), BC=(:periodic, :periodic)\n)\n\n# Star-shaped initial condition (centered at 0.5, 0.5)\nxgrid0 = allencahn2d.xspan\nygrid0 = allencahn2d.yspan\nX_grid = repeat(xgrid0', length(ygrid0), 1)    # size (Ny, Nx)\nY_grid = repeat(ygrid0, 1, length(xgrid0))     # size (Ny, Nx)\n\n# Compute angle θ for each grid point\nθ = atan.(Y_grid .- 0.5, X_grid .- 0.5)\n\n# Star radius with 6 points\nr_star = 0.25 .+ 0.1 .* cos.(6 .* θ)\n\n# Distance from center\nr_actual = sqrt.((X_grid .- 0.5).^2 .+ (Y_grid .- 0.5).^2)\n\n# Diffuse interface parameter\nϵ = allencahn2d.params[:ϵ]\n\n# Star initial condition using tanh\nux0 = tanh.((r_star .- r_actual) ./ sqrt(2 * ϵ))\nallencahn2d.IC = vec(ux0)\n\n# Operators\nA, E = allencahn2d.finite_diff_model(allencahn2d, allencahn2d.params)\n\n# Integrate\nU = allencahn2d.integrate_model(\n    allencahn2d.tspan, allencahn2d.IC; \n    linear_matrix=A, cubic_matrix=E,\n    system_input=false, const_stepsize=true,\n)\n\n# Visualize initial condition\nU2d = invec.(eachcol(U), allencahn2d.spatial_dim...)\nfig1 = Figure()\nax1 = Axis(fig1[1, 1], xlabel=\"x\", ylabel=\"y\", aspect=DataAspect(), title=\"Initial Condition\")\nhm1 = heatmap!(ax1, allencahn2d.xspan, allencahn2d.yspan, U2d[1])\nColorbar(fig1[1, 2], hm1)\nfig1\n\n# Visualize final state\nfig2 = Figure()\nax2 = Axis(fig2[1, 1], xlabel=\"x\", ylabel=\"y\", aspect=DataAspect(), title=\"Final State\")\nhm2 = heatmap!(ax2, allencahn2d.xspan, allencahn2d.yspan, U2d[end])\nColorbar(fig2[1, 2], hm2)\nfig2","category":"section"},{"location":"2D/allencahn2d/#Example-Dirichlet-BC","page":"2D Allen-Cahn Equation","title":"Example - Dirichlet BC","text":"In this example, we demonstrate phase evolution with Dirichlet boundary conditions that fix the phases at the boundaries.\n\nusing CairoMakie\nusing LinearAlgebra\nusing PolynomialModelReductionDataset: AllenCahn2DModel\nusing UniqueKronecker: invec\n\n# Setup\nΩ = ((0.0, 1.0), (0.0, 1.0))\nNx = 2^5\nNy = 2^5\nallencahn2d = AllenCahn2DModel(\n    spatial_domain=Ω, time_domain=(0,1.0), \n    Δx=(Ω[1][2] + 1/Nx)/Nx, Δy=(Ω[2][2] + 1/Ny)/Ny, Δt=1e-3,\n    params=Dict(:μ => 0.001, :ϵ => 1.0), BC=(:dirichlet, :dirichlet)\n)\n\n# Initial condition\nxg = allencahn2d.xspan\nyg = allencahn2d.yspan\nX = repeat(xg', length(yg), 1)\nY = repeat(yg, 1, length(xg))\n\nux0 = 0.1 .* sin.(2π .* X) .* cos.(2π .* Y)\nallencahn2d.IC = vec(ux0)\n\n# Dirichlet boundary values: [left, right, bottom, top]\nUbc_vals = [1.0, 1.0, -1.0, -1.0]\nUbc = repeat(reshape(Ubc_vals, 4, 1), 1, allencahn2d.time_dim)\n\n# Operators\nA, E, B = allencahn2d.finite_diff_model(allencahn2d, allencahn2d.params)\n\n# Integrate\nU = allencahn2d.integrate_model(\n    allencahn2d.tspan, allencahn2d.IC, Ubc; \n    linear_matrix=A, cubic_matrix=E, control_matrix=B,\n    system_input=true, const_stepsize=true, \n    integrator_type=:SICN,\n)\n\n# Visualize\nU2d = invec.(eachcol(U), allencahn2d.spatial_dim...)\nfig3 = Figure()\nax3 = Axis3(fig3[1, 1], xlabel=\"x\", ylabel=\"y\", zlabel=\"u(x,y,t)\", title=\"Final State\")\nsf = surface!(ax3, allencahn2d.xspan, allencahn2d.yspan, U2d[end])\nColorbar(fig3[1, 2], sf)\nfig3","category":"section"},{"location":"2D/allencahn2d/#API","page":"2D Allen-Cahn Equation","title":"API","text":"","category":"section"},{"location":"2D/allencahn2d/#PolynomialModelReductionDataset.AllenCahn2D.AllenCahn2DModel","page":"2D Allen-Cahn Equation","title":"PolynomialModelReductionDataset.AllenCahn2D.AllenCahn2DModel","text":"mutable struct AllenCahn2DModel <: AbstractModel\n\nAllen-Cahn equation Model\n\nfracpartial upartial t = muleft(fracpartial^2 upartial x^2 + fracpartial^2 upartial y^2right) - epsilon(u^3 - u)\n\nwhere u is the state variable, μ is the diffusion coefficient, ϵ is a nonlinear coefficient.\n\nFields\n\nspatial_domain::Tuple{Tuple{<:Real,<:Real}, Tuple{<:Real,<:Real}}: spatial domain (x, y)\ntime_domain::Tuple{Real,Real}: temporal domain\nparam_domain::Tuple{Real,Real}: parameter domain (diffusion coeff)\nΔx::Real: spatial grid size (x-axis)\nΔy::Real: spatial grid size (y-axis)\nΔt::Real: temporal step size\nparams::Dict{Symbol,Union{Real,AbstractArray{<:Real}}}: parameters\nxspan::Vector{<:Real}: spatial grid points (x-axis)\nyspan::Vector{<:Real}: spatial grid points (y-axis)\ntspan::Vector{<:Real}: temporal points\nspatial_dim::Int: spatial dimension\ntime_dim::Int: temporal dimension\nparam_dim::Int: parameter dimension\nIC::AbstractArray{<:Real}: initial condition\nBC::Tuple{Symbol,Symbol}: boundary condition\nfinite_diff_model::Function: model using Finite Difference\nintegrate_model::Function: integrator using Crank-Nicholson (linear) Explicit (nonlinear) method\n\n\n\n\n\n","category":"type"},{"location":"2D/allencahn2d/#PolynomialModelReductionDataset.AllenCahn2D","page":"2D Allen-Cahn Equation","title":"PolynomialModelReductionDataset.AllenCahn2D","text":"2D Allen-Cahn equation PDE Model\n\n\n\n\n\n","category":"module"},{"location":"2D/allencahn2d/#PolynomialModelReductionDataset.AllenCahn2D.finite_diff_dirichlet_model-Tuple{Real, Real, Real, Real, Dict}","page":"2D Allen-Cahn Equation","title":"PolynomialModelReductionDataset.AllenCahn2D.finite_diff_dirichlet_model","text":"finite_diff_dirichlet_model(Nx, Ny, Δx, Δy, params)\n\n\n\n\n\n\n","category":"method"},{"location":"2D/allencahn2d/#PolynomialModelReductionDataset.AllenCahn2D.finite_diff_model-Tuple{PolynomialModelReductionDataset.AllenCahn2D.AllenCahn2DModel, Dict}","page":"2D Allen-Cahn Equation","title":"PolynomialModelReductionDataset.AllenCahn2D.finite_diff_model","text":"finite_diff_model(model, params)\n\n\nCreate the matrices A (linear operator) and E (cubic operator) for the Allen-Cahn model.\n\nArguments\n\nmodel::AllenCahn2DModel: Allen-Cahn model\nparams::Dict: parameters dictionary\n\n\n\n\n\n","category":"method"},{"location":"2D/allencahn2d/#PolynomialModelReductionDataset.AllenCahn2D.finite_diff_periodic_model-Tuple{Integer, Integer, Real, Real, Dict}","page":"2D Allen-Cahn Equation","title":"PolynomialModelReductionDataset.AllenCahn2D.finite_diff_periodic_model","text":"finite_diff_periodic_model(Nx, Ny, Δx, Δy, params)\n\n\nConstruct A and B matrices for 2D heat equation with periodic boundary conditions. Returns (A, B) where B is empty (no boundary inputs for pure periodic BCs).\n\n\n\n\n\n","category":"method"},{"location":"2D/allencahn2d/#PolynomialModelReductionDataset.AllenCahn2D.integrate_model-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractArray{T}}} where T<:Real","page":"2D Allen-Cahn Equation","title":"PolynomialModelReductionDataset.AllenCahn2D.integrate_model","text":"integrate_model(tdata, u0; ...)\nintegrate_model(tdata, u0, input; kwargs...)\n\n\nIntegrate the Allen-Cahn model using the Crank-Nicholson (linear) Adam-Bashforth (nonlinear) method (CNAB) or Semi-Implicit Crank-Nicolson (SICN) method.\n\nArguments\n\ntdata::AbstractArray{T}: time data\nu0::AbstractArray{T}: initial condition\ninput::AbstractArray{T}=[]: input data\n\nKeyword Arguments\n\nlinear_matrix::AbstractArray{T,2}: linear matrix\ncubic_matrix::AbstractArray{T,2}: cubic matrix\ncontrol_matrix::AbstractArray{T,2}: control matrix\nsystem_input::Bool=false: system input flag\nconst_stepsize::Bool=false: constant step size flag\nu3_jm1::AbstractArray{T}=[]: previous cubic term\n\nReturns\n\nx::Array{T,2}: integrated model states\n\nNotes\n\nIf system_input is true, then control_matrix must be provided.\nIf const_stepsize is true, then the time step size is assumed to be constant.\nIf u3_jm1 is provided, then the cubic term at the previous time step is used.\nintegrator_type can be either :SICN for Semi-Implicit Crank-Nicolson or :CNAB for Crank-Nicolson Adam-Bashforth\n\n\n\n\n\n","category":"method"},{"location":"2D/allencahn2d/#PolynomialModelReductionDataset.AllenCahn2D.integrate_model_with_control_CNAB-Tuple{Any, Any, Any}","page":"2D Allen-Cahn Equation","title":"PolynomialModelReductionDataset.AllenCahn2D.integrate_model_with_control_CNAB","text":"integrate_model_with_control_CNAB(\n    tdata,\n    u0,\n    input;\n    linear_matrix,\n    cubic_matrix,\n    control_matrix,\n    const_stepsize,\n    u3_jm1\n)\n\n\nIntegrate the Allen-Cahn model using the Crank-Nicholson (linear) Adam-Bashforth (nonlinear) method (CNAB) with control.\n\n\n\n\n\n","category":"method"},{"location":"2D/allencahn2d/#PolynomialModelReductionDataset.AllenCahn2D.integrate_model_with_control_SICN-Tuple{Any, Any, Any}","page":"2D Allen-Cahn Equation","title":"PolynomialModelReductionDataset.AllenCahn2D.integrate_model_with_control_SICN","text":"integrate_model_with_control_SICN(\n    tdata,\n    u0,\n    input;\n    linear_matrix,\n    cubic_matrix,\n    control_matrix,\n    const_stepsize\n)\n\n\nIntegrate the Allen-Cahn model using the Crank-Nicholson (linear) Explicit (nonlinear) method. Or Semi-Implicit Crank-Nicholson (SICN) method with control input.\n\n\n\n\n\n","category":"method"},{"location":"2D/allencahn2d/#PolynomialModelReductionDataset.AllenCahn2D.integrate_model_without_control_CNAB-Tuple{Any, Any}","page":"2D Allen-Cahn Equation","title":"PolynomialModelReductionDataset.AllenCahn2D.integrate_model_without_control_CNAB","text":"integrate_model_without_control_CNAB(\n    tdata,\n    u0;\n    linear_matrix,\n    cubic_matrix,\n    const_stepsize,\n    u3_jm1\n)\n\n\nIntegrate the Allen-Cahn model using the Crank-Nicholson (linear) Adam-Bashforth (nonlinear) method (CNAB) without control.\n\n\n\n\n\n","category":"method"},{"location":"2D/allencahn2d/#PolynomialModelReductionDataset.AllenCahn2D.integrate_model_without_control_SICN-Tuple{Any, Any}","page":"2D Allen-Cahn Equation","title":"PolynomialModelReductionDataset.AllenCahn2D.integrate_model_without_control_SICN","text":"integrate_model_without_control_SICN(\n    tdata,\n    u0;\n    linear_matrix,\n    cubic_matrix,\n    const_stepsize\n)\n\n\nIntegrate the Allen-Cahn model using the Crank-Nicholson (linear) Explicit (nonlinear) method. Or, in other words, Semi-Implicit Crank-Nicholson (SICN) method without control.\n\n\n\n\n\n","category":"method"},{"location":"1D/kse/#Kuramoto-Sivashinsky-Equation","page":"Kuramoto-Sivashinsky Equation","title":"Kuramoto-Sivashinsky Equation","text":"","category":"section"},{"location":"1D/kse/#Overview","page":"Kuramoto-Sivashinsky Equation","title":"Overview","text":"The Kuramoto-Sivashinsky (KS) equation is a partial differential equation that describes the dynamics of certain spatiotemporal patterns in various physical systems, particularly in fluid dynamics and combustion processes. It was introduced by Yoshiki Kuramoto and Grigoriĭ Isaakovich Sivashinsky independently in the 1970s.\n\nThe equation is given by:\n\nbegingather*\n    u_t + uu_x + u_xx + mu u_xxxx = 0  qquad x in (-infty infty) \n    u(xt) = u(x+Lt) quad u_x(xt) = u_x(x+Lt) quad t geq 0 \nendgather*\n\nwhere:\n\nu(x t) represents the spatially and temporally varying quantity being modeled (e.g., the amplitude of certain patterns in a fluid or combustion system).\nt is time.\nx is a spatial coordinate.\n\nThe terms in the equation have the following meanings:\n\nu_t: Represents the time rate of change of the quantity u.\nuu_x: Represents advection, describing how the quantity u is transported along the spatial coordinate x by its own gradient.\nu_xx: Represents diffusion, describing how the quantity u diffuses or spreads out over space.\nu_xxxx: Represents a fourth-order spatial derivative that accounts for certain nonlinear interactions and dispersion effects.\nmu: Viscosity parameter.\n\nThe Kuramoto-Sivashinsky equation is known for producing a rich variety of complex spatiotemporal patterns, including traveling waves, oscillations, and turbulence-like behavior. It has applications in understanding and modeling various physical phenomena, such as the dynamics of flames, fluid interfaces, and certain chemical reactions. The equation's complexity and the diversity of patterns it can exhibit make it a subject of study in nonlinear dynamics and chaos theory.","category":"section"},{"location":"1D/kse/#Model","page":"Kuramoto-Sivashinsky Equation","title":"Model","text":"For our analysis, we will construct a numerical model by descretizing the original PDE and separating the system into the linear and nonlinear components in the form of \n\nbegingather*\n    dotmathbf u(t) = mathbf A mathbf u(t) + mathbf F mathbf u^langle 2rangle(t)\nendgather*\n\nwhere mathbf A, mathbf F are the linear and quadratic (non-redundant) operators respectively.\n\ntodo: Todo\nCurrently, only the periodic boundary condition is implemented for the KS equation. Hence, we disregard the control input.","category":"section"},{"location":"1D/kse/#Numerical-Integration","page":"Kuramoto-Sivashinsky Equation","title":"Numerical Integration","text":"Once we have the numerical model, we integrate it using the Crank-Nicolson and Adam-Bashforth Implicit scheme. The method is as follows.\n\nbegingather*\n    fracmathbf u(t_k+1) - mathbf u(t_k)Delta t = mathbf A left(fracmathbf u(t_k+1) + mathbf u(t_k)2right) + left frac32mathbf F left( mathbf u(t_k) right)^langle 2rangle -frac12mathbf Fleft( mathbfu(t_k-1) right)^langle 2 rangle  right \nendgather*\n\nHence \n\nbegingather*\n    mathbf u(t_k+1) = \n    begincases \n        left(mathbf I - fracDelta t2mathbf A right)^-1left left( mathbf I + fracDelta t2mathbf A right)mathbf u(t_k) + Delta tmathbf F left( mathbf u(t_k) right)^langle 2rangle right qquad  k = 1 03cm\n        left(mathbf I - fracDelta t2mathbf A right)^-1left left( mathbf I + fracDelta t2mathbf A right)mathbf u(t_k) + frac3Delta t2mathbf F left( mathbf u(t_k) right)^langle 2rangle -fracDelta t2mathbf Fleft( mathbf u(t_k-1) right)^langle 2 rangle right qquad  k geq 2\n    endcases\nendgather*","category":"section"},{"location":"1D/kse/#Finite-Difference-Model","page":"Kuramoto-Sivashinsky Equation","title":"Finite Difference Model","text":"Similar to the discretization of the 1D Heat equation, viscous Burgers' equation, and etc. we discretize the PDE using finite difference approach. In order to discretize in the spatial and temporal domains we define the grid size Delta x and time-step Delta t. Furthermore, let the subscript and superscript indicate the spatial and temporal indices respectively, i.e., u_n^k. Then we show how we discretize each term below.\n\nbeginalign*\n    u_xxxx approx frac1Delta x^4 left( u_n+2 - 4u_n+1 + 6u_n - 4u_n-1 + u_n-2 right) \n    u_xx approx frac1Delta x^2 left( u_n+1 - 2u_n + u_n-1 right) \n    u_x approx frac12Delta x left( u_n+1 - u_n-1 right) quad \nendalign*\n\nThen we can represent the KS equation model with distinct linear and nonlinear terms\n\nbegingather*\n    dot u_n = underbrace left -fracmuDelta x^4 (u_n+2 + u_n-2) + left( frac4muDelta x^4-frac1Delta x^2 right)(u_n+1 + u_n-1) + left( frac2Delta x^2-frac6muDelta x^4 right)u_n right _textlinear\n    + underbracefrac12Delta xleft( u_nu_n-1 - u_nu_n+1 right)_textnonlinear\nendgather*\n\nThus, assuming we have periodic boundary conditions, we can represent the KS equation as a linear-quadratic ODE with respect to time by expanding the above expression to all of the spatial grid:\n\nbegingather*\n    mathbfdot u(t) = mathbfAmathbf u(t) + mathbfF mathbf u^langle 2 rangle(t)\nendgather*\n\nwhere mathbf A in mathbb R^Ntimes N is the linear operator, mathbf F in mathbb R^N times N(N+1)2 is the quadratic operator, and  mathbf u^langle 2rangle in mathbb R^N(N+1)2 represents the quadratic states with no redundancy. The matrix mathbf A would be a toeplitz matrix (except for the periodic terms) and the mathbf F would be a sparse matrix.","category":"section"},{"location":"1D/kse/#Spectral-Method","page":"Kuramoto-Sivashinsky Equation","title":"Spectral Method","text":"We consider a periodic domain 0L for the solution of the Kuramoto-Sivashinsky equation. Our periodic grid has N points x_n_n=1^N, where x_n = nDelta x and Delta x = LN. With N degrees of freedom we can write the solution u(xt) as a truncated Fourier expansion with N modes:\n\nbeginalign*\nu(xt) = int_-infty^infty hat u_k(t)expleft(frac2pi j kxLright)dk approx sum_k=-N2^N2-1hatu_k(t)expleft(frac2pi jkxLright)\nendalign*\n\nNow from here, we introduce two possible methods using the Fourier transform. The first method, uses the Fast Fourier Transform (FFT) or Pseudo-Spectral (PS) method to deal with the nonlinear term. In contrast, the second method directly uses the Fourier Mode by formulating the problem with the Spectral Galerkin (SG) method.","category":"section"},{"location":"1D/kse/#Pseudo-Spectral-Method","page":"Kuramoto-Sivashinsky Equation","title":"Pseudo-Spectral Method","text":"We begin by plugging the approximate Fourier transform of u(xt) back into the original PDE which give us \n\nbeginalign*\n    dot u(xt) approx sum_k=-N2^N2-1 dothat u_k(t)expleft( frac2pi jkxL right) \n    mu u_xxxx + u_xx approx  sum_k=-N2^N2-1muleft( frac2pi j kL right)^4 hat u_k(t) expleft( frac2pi j k xL right) + sum_k=-N2^N2-1left( frac2pi j kL right)^2  hat u_k(t) expleft( frac2pi j kxL right) = -sum_k=-N2^N2-1 left left( frac2pi kL right)^2 - muleft( frac2pi  kL right)^4 right hat u_k(t) expleft( frac2pi j kxL right) \n    uu_x = frac12left( u^2 right)_x approx frac12 frac2pi j kLleft( hat u^2 right)_k = frac12 frac2pi j k L left(mathrmFFTleft u^2(t) rightright)_k\nendalign*\n\nThen if we collect the terms within the summation and multiplied by exp(2pi jk xL ) we have\n\nbegingather*\n    dothat u_k(t) = underbraceleft left( frac2pi kLright)^2 - muleft( frac2pi kL right)^4 righthat u_k(t)_textlinear - underbracefracpi j kLleft(mathrmFFTleft u^2(t) rightright)_k_textnonlinear\nendgather*\n\nFor more detail on the derivation, refer to this paper by Gentian Zavalani. If we write this in the form of mathbfdot u(t) = mathbfAmathbf u(t) + mathbfF mathbf u^langle 2 rangle(t) we will have a diagonal matrix of mathbf A and for mathbf F. The original states u(t) of the KS equation can be retained by performing the inverse FFT (iFFT) on the states hat u(t).\n\nOr you could let mathbf A and mathbf F be a vector and do element-wise multiplications to speed-up the integration process.","category":"section"},{"location":"1D/kse/#Spectral-Galerkin-(SG)-Method","page":"Kuramoto-Sivashinsky Equation","title":"Spectral Galerkin (SG) Method","text":"In the SG method, you take the inner product between the Fourier transformed expression and the exponential to retrieve the Fourier coefficient with the orthogonality condition. For example, for the -u_xx term\n\nbeginalign*\n    leftlangle -partial_x u partial_x urightrangle = leftlangle -partial_x sum_l=-N2^N2-1hat u_l(t) expleft(frac2pi j lLxright) partial_xexpleft( frac2pi j kLxright) rightrangle \n    = leftlangle - sum_l=-N2^N2-1 frac2pi j lL hat u_l(t) expleft(frac2pi j lLxright)  frac2pi jkL expleft( frac2pi j kLxright) rightrangle \n    xrightarrowl=k left( frac2pi k L right)^2 hat u_k(t)\nendalign*\n\nFor u_xxxx we obtain the same expression as the previous pseudo-spectral method, and therefore, the linear part of the model is exactly the same. However, we take a different route for the nonlinear term. If we consider the conservative advection nonlinearity, the spectral Galerkin would be as follows. \n\nbeginalign*\n    leftlangle -frac12u^2 partial_xexpleft( frac2pi jkLxright)rightrangle = leftlangle  -frac12leftsum_p=-N2^N2-1hat u_p(t) expleft(frac2pi j pLxright)rightleftsum_q=-N2^N2-1hat u_q(t) expleft(frac2pi j qLxright) right frac2pi jkLexpleft( frac2pi jkL right) rightrangle \n    =leftlangle  -frac12 sum_p=-N2^N2-1sum_q=-N2^N2-1hat u_p(t) hat u_q(t) expleftfrac2pi j (p+q)Lxright frac2pi jkLexpleft( frac2pi jkL right) rightrangle \n    xrightarrowp+q=k -fracpi jkLsum_p+q=k hat u_p(t) hat u_q(t)\nendalign*\n\nWith the linear and nonlinear terms together, we have\n\nbegingather*\n    dothat u_k(t) = underbraceleft left( frac2pi kLright)^2 - muleft( frac2pi kL right)^4 right_textlinearhat u_k(t) +  underbracefrac-pi jkL sum_p+q=khat u_p(t) hat u_q(t)_textnonlinear  \nendgather*\n\nAssume hat u_k is pure imaginary. Then let us define  hat u_k(t) = jhat v_k(t), where v_k(t) in mathbb R^N, to limit the model in the real space, which brings us to\n\nbegingather*\n    dothat v_k(t) = underbraceleft left( frac2pi kLright)^2 - muleft( frac2pi kL right)^4 righthat v_k(t)_textlinear + underbracefrac-pi kL sum_p+q=khat v_p(t) hat v_q(t)_textnonlinear quad \nendgather*\n\nThus, in the real Fourier space, the model can be expressed as \n\nbegingather*\n    dothatmathbfv(t) = mathbfAhatmathbf v(t) + mathbfF hatmathbf v^langle 2 rangle(t) quad \nendgather*\n\nNow, since the Fourier transform mathcal F is a linear operator, so is the inverse Fourier transform mathcal F^-1. Hence, the KS model in the time domain is expressed as \n\nbegingather*\n    mathcal F^-1left dothatmathbfv(t) right = mathbfAmathcal F^-1 lefthatmathbf v(t)right + mathbfF mathcal F^-1lefthatmathbf v^langle 2 rangle(t) right quad \nendgather*\n\nwhere the linear and quadratic operators do not change. For more details consult this paper. \n\nHowever if we would not want to assume hat u_k to be pure imaginary then we will just let \n\nbegingather*\n    dothatmathbfu(t) = mathbfAhatmathbf u(t) + mathbfF hatmathbf u^langle 2 rangle(t) quad \nendgather*\n\nwhere mathbf F would have complex valued entries. To acquire the original states u(t) of the KS equation we will have to perform the inverse FFT (iFFT) on the state data in the Fourier space.","category":"section"},{"location":"1D/kse/#Example","page":"Kuramoto-Sivashinsky Equation","title":"Example","text":"For this example, we follow the setup by Koike and Qian [5].\n\nusing CairoMakie\nusing LinearAlgebra\nusing PolynomialModelReductionDataset: KuramotoSivashinskyModel\n\n# Settings for the KS equation\nΩ = (0.0, 22.0)\ndt = 0.01\nN = 256\nkse = KuramotoSivashinskyModel(\n    spatial_domain=Ω, time_domain=(0.0, 300.0), diffusion_coeffs=1.0,\n    Δx=(Ω[2] - 1/N)/N, Δt=dt\n)\nDS = 100\nL = kse.spatial_domain[2]\n\n# Initial condition\na = 1.0\nb = 0.1\nu0 = a*cos.((2*π*kse.xspan)/L) + b*cos.((4*π*kse.xspan)/L)\n\n# Operators\nA, F = kse.finite_diff_model(kse, kse.diffusion_coeffs)\n\n# Integrate\nU = kse.integrate_model(kse.tspan, u0, nothing; linear_matrix=A, quadratic_matrix=F, const_stepsize=true)\n\n# Heatmap\nfig1, ax, hm = CairoMakie.heatmap(kse.tspan[1:DS:end], kse.xspan, U[:, 1:DS:end]')\nax.xlabel = L\"t\"\nax.ylabel = L\"x\"\nCairoMakie.Colorbar(fig1[1, 2], hm)\nfig1\n\n# Surface plot\nfig11, _, sf = CairoMakie.surface(kse.xspan, kse.tspan[1:DS:end], U[:, 1:DS:end], \n    axis=(type=Axis3, xlabel=L\"x\", ylabel=L\"t\", zlabel=L\"u(x,t)\"))\nCairoMakie.Colorbar(fig1[1, 2], sf)\nfig11","category":"section"},{"location":"1D/kse/#API","page":"Kuramoto-Sivashinsky Equation","title":"API","text":"","category":"section"},{"location":"1D/kse/#PolynomialModelReductionDataset.KuramotoSivashinsky.KuramotoSivashinskyModel","page":"Kuramoto-Sivashinsky Equation","title":"PolynomialModelReductionDataset.KuramotoSivashinsky.KuramotoSivashinskyModel","text":"mutable struct KuramotoSivashinskyModel <: AbstractModel\n\nKuramoto-Sivashinsky equation model\n\nfracpartial upartial t = -mufracpartial^4 upartial x^4 - fracpartial^2 upartial x^2 - ufracpartial upartial x\n\nwhere u is the state variable and mu is the viscosity coefficient.\n\nFields\n\nspatial_domain::Tuple{Real,Real}: spatial domain\ntime_domain::Tuple{Real,Real}: temporal domain\nparam_domain::Tuple{Real,Real}: parameter domain\nΔx::Real: spatial grid size\nΔt::Real: temporal step size\nBC::Symbol: boundary condition\nIC::Array{Float64}: initial condition\nxspan::Vector{Float64}: spatial grid points\ntspan::Vector{Float64}: temporal points\ndiffusion_coeffs::Union{Real,AbstractArray{<:Real}}: parameter vector\nfourier_modes::Vector{Float64}: Fourier modes\nspatial_dim::Int64: spatial dimension\ntime_dim::Int64: temporal dimension\nparam_dim::Int64: parameter dimension\nconservation_type::Symbol: conservation type\nmodel_type::Symbol: model type\nfinite_diff_model::Function: finite difference model\npseudo_spectral_model::Function: pseudo spectral model\nelementwise_pseudo_spectral_model::Function: element-wise pseudo spectral model\nspectral_galerkin_model::Function: spectral Galerkin model\nintegrate_model::Function: integrator\njacobian::Function: Jacobian matrix\n\n\n\n\n\n","category":"type"},{"location":"1D/kse/#PolynomialModelReductionDataset.KuramotoSivashinsky","page":"Kuramoto-Sivashinsky Equation","title":"PolynomialModelReductionDataset.KuramotoSivashinsky","text":"Kuramoto-Sivashinsky (KSE) model\n\n\n\n\n\n","category":"module"},{"location":"1D/kse/#PolynomialModelReductionDataset.KuramotoSivashinsky.elementwise_pseudo_spectral_model-Tuple{PolynomialModelReductionDataset.KuramotoSivashinsky.KuramotoSivashinskyModel, Float64}","page":"Kuramoto-Sivashinsky Equation","title":"PolynomialModelReductionDataset.KuramotoSivashinsky.elementwise_pseudo_spectral_model","text":"elementwise_pseudo_spectral_model(model, μ)\n\n\nGenerate A, F matrices for the Kuramoto-Sivashinsky equation using the Fast Fourier Transform method (element-wise).\n\nArguments\n\nmodel: Kuramoto-Sivashinsky equation model\nμ: parameter value\n\nReturns\n\nA: A matrix\nF: F matrix\n\n\n\n\n\n","category":"method"},{"location":"1D/kse/#PolynomialModelReductionDataset.KuramotoSivashinsky.finite_diff_model-Tuple{PolynomialModelReductionDataset.KuramotoSivashinsky.KuramotoSivashinskyModel, Real}","page":"Kuramoto-Sivashinsky Equation","title":"PolynomialModelReductionDataset.KuramotoSivashinsky.finite_diff_model","text":"finite_diff_model(model, μ)\n\n\nFinite Difference Model for the Kuramoto-Sivashinsky equation.\n\nArguments\n\nmodel::KuramotoSivashinskyModel: Kuramoto-Sivashinsky equation model\nμ::Real: parameter value\n\nReturns\n\nA: A matrix\nF: F matrix\n\n\n\n\n\n","category":"method"},{"location":"1D/kse/#PolynomialModelReductionDataset.KuramotoSivashinsky.finite_diff_periodic_conservative_model-Tuple{Real, Real, Real}","page":"Kuramoto-Sivashinsky Equation","title":"PolynomialModelReductionDataset.KuramotoSivashinsky.finite_diff_periodic_conservative_model","text":"finite_diff_periodic_conservative_model(N, Δx, μ)\n\n\nFinite Difference Model for the Kuramoto-Sivashinsky equation with periodic boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"1D/kse/#PolynomialModelReductionDataset.KuramotoSivashinsky.finite_diff_periodic_energy_preserving_model-Tuple{Real, Real, Real}","page":"Kuramoto-Sivashinsky Equation","title":"PolynomialModelReductionDataset.KuramotoSivashinsky.finite_diff_periodic_energy_preserving_model","text":"finite_diff_periodic_energy_preserving_model(N, Δx, μ)\n\n\nFinite Difference Model for the Kuramoto-Sivashinsky equation with periodic boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"1D/kse/#PolynomialModelReductionDataset.KuramotoSivashinsky.finite_diff_periodic_nonconservative_model-Tuple{Real, Real, Real}","page":"Kuramoto-Sivashinsky Equation","title":"PolynomialModelReductionDataset.KuramotoSivashinsky.finite_diff_periodic_nonconservative_model","text":"finite_diff_periodic_nonconservative_model(N, Δx, μ)\n\n\nFinite Difference Model for the Kuramoto-Sivashinsky equation with periodic boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"1D/kse/#PolynomialModelReductionDataset.KuramotoSivashinsky.integrate_elementwise_pseudo_spectral_model-Tuple{Any, Any, Vararg{Any}}","page":"Kuramoto-Sivashinsky Equation","title":"PolynomialModelReductionDataset.KuramotoSivashinsky.integrate_elementwise_pseudo_spectral_model","text":"integrate_elementwise_pseudo_spectral_model(\n    tdata,\n    IC,\n    args;\n    kwargs...\n)\n\n\nIntegrator using Crank-Nicholson Adams-Bashforth method for (FFT) (element-wise)\n\nArguments\n\ntdata: temporal points\nIC: initial condition\n\nKeyword Arguments\n\nlinear_matrix: linear matrix\nquadratic_matrix: quadratic matrix\n\nReturns\n\nu: state matrix\nuhat: state matrix in the Fourier space\n\n\n\n\n\n","category":"method"},{"location":"1D/kse/#PolynomialModelReductionDataset.KuramotoSivashinsky.integrate_finite_diff_model-Tuple{Any, Any, Vararg{Any}}","page":"Kuramoto-Sivashinsky Equation","title":"PolynomialModelReductionDataset.KuramotoSivashinsky.integrate_finite_diff_model","text":"integrate_finite_diff_model(tdata, IC, args; kwargs...)\n\n\nIntegrator using Crank-Nicholson Adams-Bashforth method for (FD). \n\nArguments\n\ntdata: temporal points\nIC: initial condition\n\nKeyword Arguments\n\nlinear_matrix: linear matrix\nquadratic_matrix: quadratic matrix\nconst_stepsize: whether to use a constant time step size\nu2_jm1: u2 at j-1\n\nReturns\n\nu: state matrix\n\n\n\n\n\n","category":"method"},{"location":"1D/kse/#PolynomialModelReductionDataset.KuramotoSivashinsky.integrate_pseudo_spectral_model-Tuple{Any, Any, Vararg{Any}}","page":"Kuramoto-Sivashinsky Equation","title":"PolynomialModelReductionDataset.KuramotoSivashinsky.integrate_pseudo_spectral_model","text":"integrate_pseudo_spectral_model(tdata, IC, args; kwargs...)\n\n\nIntegrator using Crank-Nicholson Adams-Bashforth method for (FFT)\n\nArguments\n\ntdata: temporal points\nIC: initial condition\n\nKeyword Arguments\n\nlinear_matrix: linear matrix\nquadratic_matrix: quadratic matrix\n\nReturns\n\nu: state matrix\nuhat: state matrix in the Fourier space\n\n\n\n\n\n","category":"method"},{"location":"1D/kse/#PolynomialModelReductionDataset.KuramotoSivashinsky.integrate_spectral_galerkin_model-Tuple{Any, Any, Vararg{Any}}","page":"Kuramoto-Sivashinsky Equation","title":"PolynomialModelReductionDataset.KuramotoSivashinsky.integrate_spectral_galerkin_model","text":"integrate_spectral_galerkin_model(\n    tdata,\n    IC,\n    args;\n    kwargs...\n)\n\n\nIntegrator for model produced with Spectral-Galerkin method.\n\nArguments\n\ntdata: temporal points\nIC: initial condition\n\nKeyword Arguments\n\nlinear_matrix: linear matrix\nquadratic_matrix: quadratic matrix\n\nReturns\n\nu: state matrix\nuhat: state matrix in the Fourier space\n\n\n\n\n\n","category":"method"},{"location":"1D/kse/#PolynomialModelReductionDataset.KuramotoSivashinsky.jacobian-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Kuramoto-Sivashinsky Equation","title":"PolynomialModelReductionDataset.KuramotoSivashinsky.jacobian","text":"jacobian(x; kwargs...)\n\n\nGenerate Jacobian matrix\n\nArguments\n\nx: state\n\nKeyord Arguments\n\nlinear_matrix: linear matrix\nquadratic_matrix: quadratic matrix\n\nReturns\n\nJ: Jacobian matrix\n\n\n\n\n\n","category":"method"},{"location":"1D/kse/#PolynomialModelReductionDataset.KuramotoSivashinsky.pseudo_spectral_model-Tuple{PolynomialModelReductionDataset.KuramotoSivashinsky.KuramotoSivashinskyModel, Float64}","page":"Kuramoto-Sivashinsky Equation","title":"PolynomialModelReductionDataset.KuramotoSivashinsky.pseudo_spectral_model","text":"pseudo_spectral_model(model, μ)\n\n\nGenerate A, F matrices for the Kuramoto-Sivashinsky equation using the Pseudo-Spectral/Fast Fourier Transform method.\n\nArguments\n\nmodel: Kuramoto-Sivashinsky equation model\nμ: parameter value\n\nReturns\n\nA: A matrix\nF: F matrix  (take out 1.0im)\n\n\n\n\n\n","category":"method"},{"location":"1D/kse/#PolynomialModelReductionDataset.KuramotoSivashinsky.spectral_galerkin_model-Tuple{PolynomialModelReductionDataset.KuramotoSivashinsky.KuramotoSivashinskyModel, Float64}","page":"Kuramoto-Sivashinsky Equation","title":"PolynomialModelReductionDataset.KuramotoSivashinsky.spectral_galerkin_model","text":"spectral_galerkin_model(model, μ)\n\n\nGenerate A, F matrices for the Kuramoto-Sivashinsky equation using the Spectral-Galerkin method.\n\nArguments\n\nmodel: Kuramoto-Sivashinsky equation model\nμ: parameter value\n\nReturns\n\nA: A matrix\nF: F matrix\n\n\n\n\n\n","category":"method"},{"location":"2D/heat2d/#2D-Heat-Equation","page":"2D Heat Equation","title":"2D Heat Equation","text":"","category":"section"},{"location":"2D/heat2d/#Overview","page":"2D Heat Equation","title":"Overview","text":"This is the 2D version of 1D heat equation. It is defined by\n\nu_t = mu (u_xx + u_yy)\n\nwhere xyin0L is the temperature and mu is the thermal diffusivity parameter.  ","category":"section"},{"location":"2D/heat2d/#Finite-Difference-Model","page":"2D Heat Equation","title":"Finite Difference Model","text":"The finite difference approach is similar to the 1D version but with additional complications due to the addition of an extra dimension. If the 2D domain is spatially discretized using N and M grid points for the x and y directions, respectively, then the toeplitz matrices corresponding to each x and y directions are identical to that of the 1D case which is defined by\n\nmathbfA_xinmathbbR^Ntimes N qquad textand qquad mathbfA_yinmathbbR^Mtimes M\n\nHowever, to construct the matrix for the overall system we utilize the Kronecker product. Define the state vector mathbfz which flattens the 2D grid into a vector then the linear matrix becomes\n\nmathbfA = mathbfA_y otimes mathbfI_N + mathbfI_M otimes mathbfA_x\n\nand the mathbfB matrix will be constructed such that they add the inputs to the appropriate indices of the flattened state vector mathbf z.\n\nThus, we arrive at a N-dimensional linear time-invariant (LTI) system:\n\ndotmathbfu(t) = mathbfAmathbfu(t) + mathbfBmathbfw(t)\n\nWe then consider the numerical integration scheme. For our numerical integration we can consider three approaches\n\nForward Euler\nBackward Euler\nCrank-Nicolson\n\nRefer to 1D heat equation for details on the numerical integration schemes.","category":"section"},{"location":"2D/heat2d/#Example","page":"2D Heat Equation","title":"Example","text":"using CairoMakie\nusing LinearAlgebra\nusing PolynomialModelReductionDataset: Heat2DModel\nusing UniqueKronecker: invec\n\n# Setup\nΩ = ((0.0, 1.0), (0.0, 1.0))\nNx = 2^5\nNy = 2^5\nheat2d = Heat2DModel(\n    spatial_domain=Ω, time_domain=(0,2), \n    Δx=(Ω[1][2] + 1/Nx)/Nx, Δy=(Ω[2][2] + 1/Ny)/Ny, Δt=1e-3,\n    diffusion_coeffs=0.1, BC=(:dirichlet, :dirichlet)\n)\nxgrid0 = heat2d.yspan' .* ones(heat2d.spatial_dim[1])\nygrid0 = ones(heat2d.spatial_dim[2])' .* heat2d.xspan\nux0 = sin.(2π * xgrid0) .* cos.(2π * ygrid0)\nheat2d.IC = vec(ux0)  # initial condition\n\n# Boundary condition\nUbc = [1.0, 1.0, -1.0, -1.0]\nUbc = repeat(Ubc, 1, heat2d.time_dim)\n\n# Operators\nA, B = heat2d.finite_diff_model(heat2d, heat2d.diffusion_coeffs)\n\n# Integrate\nU = heat2d.integrate_model(\n    heat2d.tspan, heat2d.IC, Ubc; linear_matrix=A, control_matrix=B, \n    system_input=true, integrator_type=:BackwardEuler\n)\n\nU2d = invec.(eachcol(U), heat2d.spatial_dim...)\nfig1 = Figure()\nax1 = Axis3(fig1[1, 1], xlabel=\"x\", ylabel=\"y\", zlabel=\"u(x,y,t)\")\nsf = surface!(ax1, heat2d.xspan, heat2d.yspan, U2d[1])\nColorbar(fig1[1, 2], sf)\nfig1\n\nfig2 = Figure()\nax2 = Axis3(fig2[1, 1], xlabel=\"x\", ylabel=\"y\", zlabel=\"u(x,y,t)\")\nsf = surface!(ax2, heat2d.xspan, heat2d.yspan, U2d[end])\nColorbar(fig2[1, 2], sf)\nfig2","category":"section"},{"location":"2D/heat2d/#API","page":"2D Heat Equation","title":"API","text":"","category":"section"},{"location":"2D/heat2d/#PolynomialModelReductionDataset.Heat2D.Heat2DModel","page":"2D Heat Equation","title":"PolynomialModelReductionDataset.Heat2D.Heat2DModel","text":"mutable struct Heat2DModel <: AbstractModel\n\n2 Dimensional Heat Equation Model\n\nfracpartial upartial t = muleft(fracpartial^2 upartial x^2 + fracpartial^2 upartial y^2right)\n\nFields\n\nspatial_domain::Tuple{Tuple{<:Real,<:Real}, Tuple{<:Real,<:Real}}: spatial domain (x, y)\ntime_domain::Tuple{Real,Real}: temporal domain\nparam_domain::Tuple{Real,Real}: parameter domain\nΔx::Real: spatial grid size (x-axis)\nΔy::Real: spatial grid size (y-axis)\nΔt::Real: temporal step size\nspatial_dim::Tuple{Int64,Int64}: spatial dimension x and y\ntime_dim::Int64: temporal dimension\nparam_dim::Int64: parameter dimension\nBC::Tuple{Symbol,Symbol}: boundary condition\nIC::Array{Float64}: initial condition\ndiffusion_coeffs::Union{AbstractArray{<:Real},Real}: diffusion coefficients\nxspan::Vector{Float64}: spatial grid points (x-axis)\nyspan::Vector{Float64}: spatial grid points (y-axis)\ntspan::Vector{Float64}: temporal points\nfinite_diff_model::Function: finite difference model\nintegrate_model::Function: integrate model\n\n\n\n\n\n","category":"type"},{"location":"2D/heat2d/#PolynomialModelReductionDataset.Heat2D","page":"2D Heat Equation","title":"PolynomialModelReductionDataset.Heat2D","text":"2D Heat Equation Model\n\n\n\n\n\n","category":"module"},{"location":"2D/heat2d/#PolynomialModelReductionDataset.Heat2D.finite_diff_model-Tuple{PolynomialModelReductionDataset.Heat2D.Heat2DModel, Real}","page":"2D Heat Equation","title":"PolynomialModelReductionDataset.Heat2D.finite_diff_model","text":"finite_diff_model(model, μ)\n\n\nGenerate A and B matrices for the 2D heat equation.\n\nArguments\n\nmodel::heat2d: 2D heat equation model\nμ::Real: diffusion coefficient\n\nReturns\n\nA::Matrix{Float64}: A matrix\nB::Matrix{Float64}: B matrix\n\n\n\n\n\n","category":"method"},{"location":"2D/heat2d/#PolynomialModelReductionDataset.Heat2D.finite_diff_periodic_model-Tuple{Integer, Integer, Real, Real, Real}","page":"2D Heat Equation","title":"PolynomialModelReductionDataset.Heat2D.finite_diff_periodic_model","text":"Construct A and B matrices for 2D heat equation with periodic boundary conditions. Returns (A, B) where B is empty (no boundary inputs for pure periodic BCs).\n\n\n\n\n\n","category":"method"},{"location":"2D/heat2d/#PolynomialModelReductionDataset.Heat2D.integrate_model-NTuple{5, Any}","page":"2D Heat Equation","title":"PolynomialModelReductionDataset.Heat2D.integrate_model","text":"integrate_model(A, B, U, tdata, IC)\n\n\nIntegrate the 2D heat equation model.\n\nArguments\n\nA::Matrix{Float64}: A matrix\nB::Matrix{Float64}: B matrix\nU::Vector{Float64}: input vector\ntdata::Vector{Float64}: time points\nIC::Vector{Float64}: initial condition\n\nReturns\n\nstate::Matrix{Float64}: state matrix\n\n\n\n\n\n","category":"method"},{"location":"2D/heat2d/#PolynomialModelReductionDataset.Heat2D.integrate_model-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractArray{T}}} where T<:Real","page":"2D Heat Equation","title":"PolynomialModelReductionDataset.Heat2D.integrate_model","text":"integrate_model(tdata, u0; ...)\nintegrate_model(tdata, u0, input; kwargs...)\n\n\nIntegrate the 2D Allen-Cahn Equation Model using 3 different methods:\n\nForward Euler\nBackward Euler\nCrank Nicolson\n\nArguments\n\ntdata::AbstractVector{T}: time data\nx0::AbstractVector{T}: initial condition\nu::AbstractArray{T}=[]: input data\n\nKeyword Arguments\n\noperators: operators A and B\nsystem_input::Bool=false: system input flag\nintegrator_type::Symbol=:ForwardEuler: integrator type\n\nReturns\n\nx::Array{T,2}: integrated model states\n\nNotes\n\nInput is assumed to be a matrix of size (spatial dimension x time dimension). You will receive a warning if the input is a tall vector/column vector.\noperators should be in the order of [A, B] if system_input is true.\n\n\n\n\n\n","category":"method"},{"location":"1D/kawahara/#Kawahara-Equation","page":"Kawahara Equation","title":"Kawahara Equation","text":"","category":"section"},{"location":"1D/kawahara/#Overview","page":"Kawahara Equation","title":"Overview","text":"The Kawahara equation (also known as the dispersively-modified Kuramoto-Sivashinsky equation or Benney-Lin equation) is a nonlinear partial differential equation that describes the evolution of certain physical systems, particularly in fluid dynamics and plasma physics. It extends the Kuramoto-Sivashinsky equation by including higher-order dispersion terms.\n\nThe equation can be written in several forms depending on which dispersion terms are included:\n\nFirst-order dispersion:\n\nfracpartial upartial t = -mufracpartial^4 upartial x^4 - fracpartial^2 upartial x^2 - ufracpartial upartial x - deltafracpartial upartial x\n\nThird-order dispersion:\n\nfracpartial upartial t = -mufracpartial^4 upartial x^4 - fracpartial^2 upartial x^2 - ufracpartial upartial x - deltafracpartial^3 upartial x^3\n\nFifth-order dispersion:\n\nfracpartial upartial t = -mufracpartial^4 upartial x^4 - fracpartial^2 upartial x^2 - ufracpartial upartial x - nufracpartial^5 upartial x^5\n\nCombined dispersion (third and fifth order):\n\nfracpartial upartial t = -mufracpartial^4 upartial x^4 - fracpartial^2 upartial x^2 - ufracpartial upartial x - deltafracpartial^3 upartial x^3 - nufracpartial^5 upartial x^5\n\nwhere:\n\nu(x t) is the state variable\nmu is the viscosity coefficient (fourth-order diffusion)\ndelta is the first-order or third-order dispersion coefficient\nnu is the fifth-order dispersion coefficient\nThe term -ufracpartial upartial x represents nonlinear advection\n\nThe Kawahara equation exhibits a rich variety of spatiotemporal behaviors including traveling waves, solitary waves, and chaotic dynamics. The higher-order dispersion terms provide additional stabilization mechanisms compared to the standard Kuramoto-Sivashinsky equation.","category":"section"},{"location":"1D/kawahara/#Model","page":"Kawahara Equation","title":"Model","text":"For our analysis, we discretize the original PDE and separate the system into linear and nonlinear components:\n\ndotmathbfu(t) = mathbfAmathbfu(t) + mathbfFmathbfu^langle 2rangle(t)\n\nwhere:\n\nmathbfA is the linear operator (containing diffusion, anti-diffusion, and dispersion terms)\nmathbfF is the quadratic operator (for the nonlinear advection)\nmathbfu^langle 2rangle represents the quadratic states (non-redundant)\n\nnote: Note\nCurrently, only periodic boundary conditions are implemented for the Kawahara equation.","category":"section"},{"location":"1D/kawahara/#Conservation-Forms","page":"Kawahara Equation","title":"Conservation Forms","text":"The implementation supports three different conservation forms for the nonlinear term:\n\nNon-Conservative (NC): -ufracpartial upartial x\nConservative (C): -frac12fracpartial (u^2)partial x\nEnergy-Preserving (EP): A skew-symmetric discretization that preserves discrete energy\n\nThe choice of conservation form affects the numerical properties and long-term behavior of the solution.","category":"section"},{"location":"1D/kawahara/#Numerical-Integration","page":"Kawahara Equation","title":"Numerical Integration","text":"We integrate the Kawahara model using the Crank-Nicolson Adams-Bashforth (CNAB) method, treating the linear terms implicitly and the nonlinear term explicitly:\n\nmathbfu(t_k+1) = \nbegincases \n    left(mathbfI - fracDelta t2mathbfAright)^-1leftleft(mathbfI + fracDelta t2mathbfAright)mathbfu(t_k) + Delta tmathbfFleft(mathbfu(t_k)right)^langle 2rangleright  k = 1 03cm\n    left(mathbfI - fracDelta t2mathbfAright)^-1leftleft(mathbfI + fracDelta t2mathbfAright)mathbfu(t_k) + frac3Delta t2mathbfFleft(mathbfu(t_k)right)^langle 2rangle - fracDelta t2mathbfFleft(mathbfu(t_k-1)right)^langle 2rangleright  k geq 2\nendcases\n\nThis scheme provides second-order accuracy in time and good stability properties for the stiff linear terms.","category":"section"},{"location":"1D/kawahara/#Finite-Difference-Model","page":"Kawahara Equation","title":"Finite Difference Model","text":"We discretize the spatial derivatives using centered finite differences. The discretization depends on the dispersion order:\n\nFor first-order dispersion (delta partial_x u):\n\nu_x approx frac12Delta x(u_n+1 - u_n-1)\n\nFor third-order dispersion (delta partial_x^3 u):\n\nu_xxx approx frac12Delta x^3(u_n+2 - 2u_n+1 + 2u_n-1 - u_n-2)\n\nFor fifth-order dispersion (nu partial_x^5 u):\n\nu_xxxxx approx frac12Delta x^5(u_n+3 - 4u_n+2 + 5u_n+1 - 5u_n-1 + 4u_n-2 - u_n-3)\n\nFor the fourth-order diffusion:\n\nu_xxxx approx frac1Delta x^4(u_n+2 - 4u_n+1 + 6u_n - 4u_n-1 + u_n-2)\n\nFor the anti-diffusion:\n\nu_xx approx frac1Delta x^2(u_n+1 - 2u_n + u_n-1)\n\nThe linear operator mathbfA combines all these terms into a sparse matrix with periodic boundary conditions, resulting in a circulant-like structure.\n\nThe quadratic operator mathbfF discretizes the nonlinear advection term according to the chosen conservation form.","category":"section"},{"location":"1D/kawahara/#Example-Third-order-Dispersion","page":"Kawahara Equation","title":"Example - Third-order Dispersion","text":"using CairoMakie\nusing LinearAlgebra\nusing PolynomialModelReductionDataset: KawaharaModel\n\n# Settings\nΩ = (0.0, 50.0)\ndt = 0.01\nN = 256\nkawahara = KawaharaModel(\n    spatial_domain=Ω, time_domain=(0.0, 150.0), \n    params=Dict(:mu => 1.0, :delta => 0.15, :nu => 0.0),\n    dispersion_order=3,\n    conservation_type=:C,\n    Δx=(Ω[2] - 1/N)/N, Δt=dt\n)\nDS = 100\nL = kawahara.spatial_domain[2]\n\n# Initial condition\na = 1.0\nb = 0.1\nu0 = a*cos.((2*π*kawahara.xspan)/L) + b*cos.((4*π*kawahara.xspan)/L)\n\n# Operators\nA, F = kawahara.finite_diff_model(kawahara, kawahara.params[:mu], kawahara.params[:delta])\n\n# Integrate\nU = kawahara.integrate_model(\n    kawahara.tspan, u0, nothing; \n    linear_matrix=A, quadratic_matrix=F, const_stepsize=true\n)\n\n# Heatmap\nfig1, ax, hm = CairoMakie.heatmap(kawahara.tspan[1:DS:end], kawahara.xspan, U[:, 1:DS:end]')\nax.xlabel = L\"t\"\nax.ylabel = L\"x\"\nCairoMakie.Colorbar(fig1[1, 2], hm)\nfig1\n\n# Surface plot\nfig2, _, sf = CairoMakie.surface(kawahara.xspan, kawahara.tspan[1:DS:end], U[:, 1:DS:end], \n    axis=(type=Axis3, xlabel=L\"x\", ylabel=L\"t\", zlabel=L\"u(x,t)\"))\nCairoMakie.Colorbar(fig2[1, 2], sf)\nfig2","category":"section"},{"location":"1D/kawahara/#Example-Fifth-order-Dispersion","page":"Kawahara Equation","title":"Example - Fifth-order Dispersion","text":"using CairoMakie\nusing LinearAlgebra\nusing PolynomialModelReductionDataset: KawaharaModel\n\n# Settings\nΩ = (0.0, 50.0)\ndt = 0.01\nN = 256\nkawahara = KawaharaModel(\n    spatial_domain=Ω, time_domain=(0.0, 150.0), \n    params=Dict(:mu => 1.0, :delta => 0.0, :nu => 0.05),\n    dispersion_order=5,\n    conservation_type=:EP,\n    Δx=(Ω[2] - 1/N)/N, Δt=dt\n)\nDS = 100\nL = kawahara.spatial_domain[2]\n\n# Initial condition\na = 1.0\nb = 0.1\nu0 = a*cos.((2*π*kawahara.xspan)/L) + b*cos.((4*π*kawahara.xspan)/L)\n\n# Operators\nA, F = kawahara.finite_diff_model(kawahara, kawahara.params[:mu], kawahara.params[:delta], kawahara.params[:nu])\n\n# Integrate\nU = kawahara.integrate_model(\n    kawahara.tspan, u0, nothing; \n    linear_matrix=A, quadratic_matrix=F, const_stepsize=true\n)\n\n# Heatmap\nfig3, ax, hm = CairoMakie.heatmap(kawahara.tspan[1:DS:end], kawahara.xspan, U[:, 1:DS:end]')\nax.xlabel = L\"t\"\nax.ylabel = L\"x\"\nCairoMakie.Colorbar(fig3[1, 2], hm)\nfig3","category":"section"},{"location":"1D/kawahara/#API","page":"Kawahara Equation","title":"API","text":"","category":"section"},{"location":"1D/kawahara/#PolynomialModelReductionDataset.Kawahara.KawaharaModel","page":"Kawahara Equation","title":"PolynomialModelReductionDataset.Kawahara.KawaharaModel","text":"mutable struct KawaharaModel <: AbstractModel\n\nKawahara equation model (also known as dispersively-modified Kuramoto-Sivashinsky  equation or Benney-Lin equation) is a nonlinear PDE that describes the evolution  of certain physical systems, such as fluid dynamics and plasma physics. The equation can be written in several forms, including:\n\nfracpartial upartial t = -mufracpartial^4 upartial x^4 - \nfracpartial^2 upartial x^2 - ufracpartial upartial x - \ndeltafracpartial upartial x\n\nor \n\nfracpartial upartial t = -mufracpartial^4 upartial x^4 - \nfracpartial^2 upartial x^2 - ufracpartial upartial x - \ndeltafracpartial^3 upartial x^3\n\nor \n\nfracpartial upartial t = -mufracpartial^4 upartial x^4 - \nfracpartial^2 upartial x^2 - ufracpartial upartial x - \nnufracpartial^3 upartial x^5\n\nor \n\nfracpartial upartial t = -mufracpartial^4 upartial x^4 - \nfracpartial^2 upartial x^2 - ufracpartial upartial x - \ndeltafracpartial^3 upartial x^3 - \nnufracpartial^5 upartial x^5\n\nwhere u is the state variable, mu is the viscosity coefficient, delta is the 1st or 3rd order dispersion coefficient, and nu  is the 5th order dispersion coefficient.\n\nFields\n\nspatial_domain::Tuple{Real,Real}: spatial domain\ntime_domain::Tuple{Real,Real}: temporal domain\nparam_domain::Dict{Symbol,Tuple{Real,Real}}: parameter domains\nΔx::Real: spatial grid size\nΔt::Real: temporal step size\nBC::Symbol: boundary condition\nIC::Array{Float64}: initial condition\nxspan::Vector{Float64}: spatial grid points\ntspan::Vector{Float64}: temporal points\nparams::Dict{Symbol,<:Union{<:Real,<:AbstractArray{<:Real}}}: parameters (diffusion and dispersion coefficients)\nfourier_modes::Vector{Float64}: Fourier modes\nspatial_dim::Int64: spatial dimension\ntime_dim::Int64: temporal dimension\nparam_dim::Dict{Symbol,Int64}: parameter dimensions\nconservation_type::Symbol: conservation type\nfinite_diff_model::Function: finite difference model\nintegrate_model::Function: integrator\njacobian::Function: Jacobian matrix\n\n\n\n\n\n","category":"type"},{"location":"1D/kawahara/#PolynomialModelReductionDataset.Kawahara","page":"Kawahara Equation","title":"PolynomialModelReductionDataset.Kawahara","text":"Kawahara or Dispersively-Modified Kuramoto-Sivashinsky Equation model\n\n\n\n\n\n","category":"module"},{"location":"1D/kawahara/#PolynomialModelReductionDataset.Kawahara.finite_diff_model","page":"Kawahara Equation","title":"PolynomialModelReductionDataset.Kawahara.finite_diff_model","text":"finite_diff_model(model, μ, δ)\nfinite_diff_model(model, μ, δ, ν)\n\n\nFinite Difference Model for the Kuramoto-Sivashinsky equation.\n\nArguments\n\nmodel::KawaharaModel: Kuramoto-Sivashinsky equation model\nμ::Real: parameter value\n\nReturns\n\nA: A matrix\nF: F matrix\n\n\n\n\n\n","category":"function"},{"location":"1D/kawahara/#PolynomialModelReductionDataset.Kawahara.finite_diff_periodic_conservative_model","page":"Kawahara Equation","title":"PolynomialModelReductionDataset.Kawahara.finite_diff_periodic_conservative_model","text":"finite_diff_periodic_conservative_model(N, Δx, μ, δ, ord)\nfinite_diff_periodic_conservative_model(N, Δx, μ, δ, ord, ν)\n\n\nFinite Difference Model for the Kuramoto-Sivashinsky equation with periodic  boundary condition.\n\n\n\n\n\n","category":"function"},{"location":"1D/kawahara/#PolynomialModelReductionDataset.Kawahara.finite_diff_periodic_energy_preserving_model","page":"Kawahara Equation","title":"PolynomialModelReductionDataset.Kawahara.finite_diff_periodic_energy_preserving_model","text":"finite_diff_periodic_energy_preserving_model(\n    N,\n    Δx,\n    μ,\n    δ,\n    ord\n)\nfinite_diff_periodic_energy_preserving_model(\n    N,\n    Δx,\n    μ,\n    δ,\n    ord,\n    ν\n)\n\n\nFinite Difference Model for the Kuramoto-Sivashinsky equation with periodic  boundary condition.\n\n\n\n\n\n","category":"function"},{"location":"1D/kawahara/#PolynomialModelReductionDataset.Kawahara.finite_diff_periodic_nonconservative_model","page":"Kawahara Equation","title":"PolynomialModelReductionDataset.Kawahara.finite_diff_periodic_nonconservative_model","text":"finite_diff_periodic_nonconservative_model(N, Δx, μ, δ, ord)\nfinite_diff_periodic_nonconservative_model(\n    N,\n    Δx,\n    μ,\n    δ,\n    ord,\n    ν\n)\n\n\nFinite Difference Model for the Kuramoto-Sivashinsky equation with periodic  boundary condition.\n\n\n\n\n\n","category":"function"},{"location":"1D/kawahara/#PolynomialModelReductionDataset.Kawahara.integrate_finite_diff_model-Tuple{Any, Any, Vararg{Any}}","page":"Kawahara Equation","title":"PolynomialModelReductionDataset.Kawahara.integrate_finite_diff_model","text":"integrate_finite_diff_model(tdata, IC, args; kwargs...)\n\n\nIntegrator using Crank-Nicholson Adams-Bashforth method for (FD). \n\nArguments\n\ntdata: temporal points\nIC: initial condition\n\nKeyword Arguments\n\nlinear_matrix: linear matrix\nquadratic_matrix: quadratic matrix\nconst_stepsize: whether to use a constant time step size\nu2_jm1: u2 at j-1\n\nReturns\n\nu: state matrix\n\n\n\n\n\n","category":"method"},{"location":"#Polynomial-Model-Reduction-Dataset","page":"Home","title":"Polynomial Model Reduction Dataset","text":"This GitHub repo includes various polynomial structured ordinary differential equations (ODEs) models and its dataset derived from large-scale partial differential equations (PDEs). The polynomial models are defined by\n\ndotx(t) = Ax(t) + H(x(t) otimes x(t)) + G(x(t) otimes x(t) otimes x(t)) + Bu(t)\n\nwhere\n\nx in mathbbR^n: state variable vector\nu in mathbbR^m: control input vector\nA in mathbbR^n times n: linear system matrix\nH in mathbbR^n times n^2: quadratic system matrix\nG in mathbbR^n times n^3: cubic system matrix\nB in mathbbR^n times m: control/input matrix\notimes: Kronecker product\n\nWe call the AFHB matrices the operators of the system, and these operators are constructed using mainly finite difference scheme. This package constructs these operators for a given set of parameters and allows you to numerically integrate the system to collect the solution data for PDEs. The main goal of this package is to accelerate the development of novel model reduction approaches by making these models and dataset available to everyone.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"You can install it using the command\n\nusing Pkg\nPkg.add(\"PolynomialModelReductionDataset\")\nusing PolynomialModelReductionDataset","category":"section"},{"location":"#Currently-Offered-Models","page":"Home","title":"Currently Offered Models","text":"Model Equation Boundary Conditions\n1D Heat u_t = mu u_xx periodic, Dirichlet, mixed, Robin\nViscous Burgers' u_t = mu u_xx - uu_x periodic, Dirichlet\nFitzHugh-Nagumo u_t = epsilon^2 u_xx + u(u-01)(1-u) - v + g <br/> v_t = hu + gamma v + g Dirichlet and Neumann\nFisher-KPP u_t = D u_xx + ru(1-u) periodic, Dirichlet, Dirichlet and Neumann (mixed)\nAllen-Cahn u_t = mu u_xx - epsilon(u - u^3) periodic, Dirichlet, Dirichlet and Neumann (mixed)\nKuramoto-Sivashinsky u_t = -mu u_xxxx - u_xx - uu_x periodic\nKawahara u_t = -mu u_xxxx - u_xx - uu_x - delta u_xxx - nu u_xxxxx periodic\nModified Korteweg-de Vries u_t = -alpha u_xxx - beta u^2u_xx periodic, Dirichlet\nModified Korteweg-de Vries-Burgers u_t = -alpha u_xxx - beta u^2u_xx + gamma u_xx periodic, Dirichlet\nGardner u_t = -alpha u_xxx + beta uu_x + gamma u^2u_x periodic, Dirichlet\nDamped Gardner-Burgers' u_t = -alpha u_xxx + beta uu_x + gamma u^2u_x + delta u_xx + epsilon u periodic, Dirichlet\n2D Heat u_t = mu(u_xx + u_yy) periodic, Dirichlet\n2D Allen-Cahn u_t = mu(u_xx + u_yy) - epsilon(u^3 - u) periodic, Dirichlet","category":"section"},{"location":"#Non-Redundant-Expressions","page":"Home","title":"Non-Redundant Expressions","text":"In this package, you will see a slightly different version of operators from what is defined above. Those are operators including only the non-redundant terms which eliminate the redundancy coming from the symmetry of Kronecker products. For ease of exposition, we will only introduce the non-redundant operators. For more info, please see this page.\n\nFor the quadratic and cubic operators we define the non-redundant counterparts as follows:\n\nF in mathbbR^n times n(n+1)2: quadratic operator corresponding to the non-redundant terms of x otimes x\nE in mathbbR^n times n(n+1)(n+2)6: cubic operator corresponding to the non-redundant terms of x otimes x otimes x\n\nThen, the ODE is defined by\n\ndotx(t) = Ax(t) + F(x(t) oslash x(t)) + E(x(t) oslash x(t) oslash x(t)) + Bu(t)\n\nwhere oslash is the unique Kronecker product defined in UniqueKronecker.jl.","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"Contributions are welcome! If you find a bug or have a feature request, please open an issue. If you'd like to contribute code, feel free to submit a pull request.","category":"section"},{"location":"#License","page":"Home","title":"License","text":"This project is licensed under the MIT License.","category":"section"},{"location":"1D/mKdV/#Modified-Korteweg-de-Vries-Equation","page":"Modified Korteweg-de Vries Equation","title":"Modified Korteweg-de Vries Equation","text":"The Modified Korteweg-de Vries (mKdV) equation is a nonlinear partial differential equation (PDE) that is a variation of the well-known Korteweg-de Vries (KdV) equation. The mKdV equation is significant in the study of solitons, integrable systems, and nonlinear wave propagation. It models phenomena in various physical contexts, such as nonlinear optics, plasma physics, and fluid dynamics.\n\nThe standard form of the mKdV equation in one spatial dimension is:\n\nu_t + alpha u_xxx + beta u^2u_x = 0\n\nWhere:\n\nu(x t) is a scalar function representing the wave profile at position x and time t.\nalpha and beta are parameters.","category":"section"},{"location":"1D/mKdV/#Key-Features","page":"Modified Korteweg-de Vries Equation","title":"Key Features","text":"Nonlinearity: The term u^2 fracpartial upartial x introduces cubic nonlinearity, leading to rich dynamics.\nDispersion: The third-order derivative fracpartial^3 upartial x^3 accounts for dispersive effects.\nIntegrability: The mKdV equation is integrable via the inverse scattering transform (IST), similar to the KdV equation.","category":"section"},{"location":"1D/mKdV/#Physical-Interpretation","page":"Modified Korteweg-de Vries Equation","title":"Physical Interpretation","text":"Nonlinear Wave Propagation: Describes the evolution of nonlinear waves in dispersive media.\nSolitons: Supports solitary wave solutions that maintain their shape during propagation and after interactions.\nApplications:\nPlasma Physics: Modeling ion-acoustic waves in plasmas.\nNonlinear Optics: Describing pulse propagation in optical fibers under certain conditions.\nFluid Dynamics: Representing internal waves in stratified fluids.","category":"section"},{"location":"1D/mKdV/#Properties","page":"Modified Korteweg-de Vries Equation","title":"Properties","text":"","category":"section"},{"location":"1D/mKdV/#Soliton-Solutions","page":"Modified Korteweg-de Vries Equation","title":"Soliton Solutions","text":"The mKdV equation admits soliton solutions, which can be obtained using methods like the inverse scattering transform.\nOne-Soliton Solution:\nFor the focusing mKdV equation, the one-soliton solution is:\nu(x t) = pm fracvsqrt2 operatornamesech left( fracvsqrt2 (x - v t - x_0) right)\nWhere:\nv is the velocity of the soliton.\nx_0 is the initial position.","category":"section"},{"location":"1D/mKdV/#Miura-Transformation","page":"Modified Korteweg-de Vries Equation","title":"Miura Transformation","text":"There exists a connection between the mKdV and KdV equations via the Miura transformation:\nu = w_x + w^2\nWhere w satisfies the KdV equation. This transformation maps solutions of the mKdV equation to solutions of the KdV equation, linking their integrable structures.","category":"section"},{"location":"1D/mKdV/#Generalizations","page":"Modified Korteweg-de Vries Equation","title":"Generalizations","text":"Higher-Order mKdV Equations: Including higher-order terms to model more complex physical situations.\nCoupled mKdV Equations: Systems of mKdV equations modeling interactions between multiple wave modes.\nNon-integrable Variants: Modifications that break integrability but model additional physical effects.","category":"section"},{"location":"1D/mKdV/#Applications","page":"Modified Korteweg-de Vries Equation","title":"Applications","text":"Nonlinear Optics: Pulse shaping and propagation in optical fibers with specific nonlinear characteristics.\nPlasma Physics: Studying nonlinear structures like solitons and shock waves in plasma environments.\nMathematical Physics: Exploring integrable systems, symmetry reductions, and exactly solvable models.","category":"section"},{"location":"1D/mKdV/#Model","page":"Modified Korteweg-de Vries Equation","title":"Model","text":"The Modified Korteweg-de Vries equation becomes a cubic model:\n\ndotmathbfu(t) = mathbfAu(t) + mathbfG(mathbfu(t) otimes mathbfu(t) otimes mathbfu(t)) + mathbfBw(t)\n\nor \n\ndotmathbfu(t) = mathbfAu(t) + mathbfE(mathbfu(t) oslash mathbfu(t) oslash mathbfu(t)) + mathbfBw(t)\n\nwhere\n\nmathbfuinmathbbR^N: the state vector\nmathbfwinmathbbR^m: the input vector\nmathbfAinmathbbR^Ntimes N: the linear state matrix\nmathbfGinmathbbR^Ntimes N^3: the cubic state matrix with redundancy\nmathbfEinmathbbR^Ntimes N(N+1)(N+2)6: the cubic state matrix without redundancy\nmathbfBinmathbbR^Ntimes m: the control input matrix","category":"section"},{"location":"1D/mKdV/#Numerical-Integration","page":"Modified Korteweg-de Vries Equation","title":"Numerical Integration","text":"For the numerical integration we consider two methods:\n\nSemi-Implicit Euler (SIE)\nCrank-Nicolson Adam-Bashforth (CNAB)\n\nFor the exact expressions of the time-stepping check Allen-Cahn equation.","category":"section"},{"location":"1D/mKdV/#Example","page":"Modified Korteweg-de Vries Equation","title":"Example","text":"using CairoMakie\nusing LinearAlgebra\nusing PolynomialModelReductionDataset: ModifiedKortewegDeVriesModel\n\n# Setup\nΩ = (0.0, 3.0)\nNx = 2^8; dt = 1e-3\nmKdV = ModifiedKortewegDeVriesModel(\n    spatial_domain=Ω, time_domain=(0.0, 3.0), Δx=(Ω[2] + 1/Nx)/Nx, Δt=dt,\n    params=Dict(:a => 1, :b => 3), BC=:dirichlet,\n)\nDS = 100\nmKdV.IC = 2 * cos.(2π * mKdV.xspan / (Ω[2] - Ω[1])) # + 0.5 * cos.(4π * mKdV.xspan / (Ω[2] - Ω[1]))\nUbc1 = 0.5ones(1,mKdV.time_dim)\nUbc2 = -0.5ones(1,mKdV.time_dim)\nUbc = [Ubc1; Ubc2]\n\n# Operators\nA, E, B = mKdV.finite_diff_model(mKdV, mKdV.params)\n\n# Integrate\nU = mKdV.integrate_model(\n    mKdV.tspan, mKdV.IC, Ubc; \n    linear_matrix=A, cubic_matrix=E, control_matrix=B,\n    system_input=true, integrator_type=:CNAB,\n)\n\n# Surface plot\nfig3, _, sf = CairoMakie.surface(mKdV.xspan, mKdV.tspan[1:DS:end], U[:, 1:DS:end], \n    axis=(type=Axis3, xlabel=L\"x\", ylabel=L\"t\", zlabel=L\"u(x,t)\"))\nCairoMakie.Colorbar(fig3[1, 2], sf)\nfig3\n\n# Flow field\nfig4, ax, hm = CairoMakie.heatmap(mKdV.xspan, mKdV.tspan[1:DS:end], U[:, 1:DS:end])\nax.xlabel = L\"x\"\nax.ylabel = L\"t\"\nCairoMakie.Colorbar(fig4[1, 2], hm)\nfig4","category":"section"},{"location":"1D/mKdV/#API","page":"Modified Korteweg-de Vries Equation","title":"API","text":"","category":"section"},{"location":"1D/mKdV/#PolynomialModelReductionDataset.ModifiedKortewegDeVries.ModifiedKortewegDeVriesModel","page":"Modified Korteweg-de Vries Equation","title":"PolynomialModelReductionDataset.ModifiedKortewegDeVries.ModifiedKortewegDeVriesModel","text":"mutable struct ModifiedKortewegDeVriesModel <: AbstractModel\n\nModified Korteweg-de Vries equation model\n\nfracpartial upartial t = -alphafracpartial^3 upartial x^3 - beta u^2fracpartial upartial x\n\nFields\n\nspatial_domain::Tuple{Real,Real}: spatial domain\ntime_domain::Tuple{Real,Real}: temporal domain\nparam_domain::Tuple{Real,Real}: parameter domain\nΔx::Real: spatial grid size\nΔt::Real: temporal step size\nBC::Symbol: boundary condition\nIC::Array{Float64}: initial condition\nxspan::Vector{Float64}: spatial grid points\ntspan::Vector{Float64}: temporal points\nspatial_dim::Int64: spatial dimension\ntime_dim::Int64: temporal dimension\nparams::Union{Real,AbstractArray{<:Real}}: parameter vector\nparam_dim::Int64: parameter dimension\nfinite_diff_model::Function: model using Finite Difference\nintegrate_model::Function: model integration\n\n\n\n\n\n","category":"type"},{"location":"1D/mKdV/#PolynomialModelReductionDataset.ModifiedKortewegDeVries","page":"Modified Korteweg-de Vries Equation","title":"PolynomialModelReductionDataset.ModifiedKortewegDeVries","text":"Modified Korteweg-de Vries (mKdV) equation\n\n\n\n\n\n","category":"module"},{"location":"1D/mKdV/#PolynomialModelReductionDataset.ModifiedKortewegDeVries.finite_diff_dirichlet_model-Tuple{Real, Real, Real, Dict}","page":"Modified Korteweg-de Vries Equation","title":"PolynomialModelReductionDataset.ModifiedKortewegDeVries.finite_diff_dirichlet_model","text":"finite_diff_dirichlet_model(N, Δx, Δt, params)\n\n\nFinite Difference Model for the Gardner equation with Dirichlet boundary condition (Non-conservative).\n\n\n\n\n\n","category":"method"},{"location":"1D/mKdV/#PolynomialModelReductionDataset.ModifiedKortewegDeVries.finite_diff_model-Tuple{PolynomialModelReductionDataset.ModifiedKortewegDeVries.ModifiedKortewegDeVriesModel, Dict}","page":"Modified Korteweg-de Vries Equation","title":"PolynomialModelReductionDataset.ModifiedKortewegDeVries.finite_diff_model","text":"finite_diff_model(model, params)\n\n\nFinite Difference Model for mKdV equation\n\nArguments\n\nmodel::ModifiedKortewegDeVriesModel: mKdV model\nparams::Real: params including a, b, c\n\nReturns\n\noperators\n\n\n\n\n\n","category":"method"},{"location":"1D/mKdV/#PolynomialModelReductionDataset.ModifiedKortewegDeVries.finite_diff_periodic_model-Tuple{Real, Real, Dict}","page":"Modified Korteweg-de Vries Equation","title":"PolynomialModelReductionDataset.ModifiedKortewegDeVries.finite_diff_periodic_model","text":"finite_diff_periodic_model(N, Δx, params)\n\n\nGenerate A and E matrices for the Gardner equation for periodic boundary condition (Non-conservative).\n\n\n\n\n\n","category":"method"},{"location":"1D/mKdV/#PolynomialModelReductionDataset.ModifiedKortewegDeVries.integrate_model-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractArray{T}}} where T<:Real","page":"Modified Korteweg-de Vries Equation","title":"PolynomialModelReductionDataset.ModifiedKortewegDeVries.integrate_model","text":"integrate_model(tdata, u0; ...)\nintegrate_model(tdata, u0, input; kwargs...)\n\n\nIntegrate the mKdV model using the Semi-Implicit Euler (SIE) or Crank-Nicolson Adam-Bashforth (CNAB) scheme with or without control.\n\nArguments\n\ntdata::AbstractArray{T}: time data\nu0::AbstractArray{T}: initial condition\ninput::AbstractArray{T}=[]: input data\n\nKeyword Arguments\n\nlinear_matrix::AbstractArray{T,2}: linear matrix\ncubic_matrix::AbstractArray{T,2}: cubic matrix\ncontrol_matrix::AbstractArray{T,2}: control matrix\nsystem_input::Bool=false: system input flag\nconst_stepsize::Bool=false: constant step size flag\nu3_jm1::AbstractArray{T,2}: cubic matrix at j-1\nintegrator_type::Symbol=:CNAB: integrator type\n\nReturns\n\nu::Array{T,2}: integrated model states\n\nNotes\n\nIf system_input is true, the input data is assumed to be a matrix of size (spatial dimension x time dimension).\nIf const_stepsize is true, the time step size is assumed to be constant.\nIf u3_jm1 is provided, the cubic matrix at j-1 is used in the CNAB scheme.\nThe integrator type can be either :SIE for Semi-Implicit Euler or :CNAB for Crank-Nicolson Adam-Bashforth.\n\n\n\n\n\n","category":"method"},{"location":"1D/mKdV/#PolynomialModelReductionDataset.ModifiedKortewegDeVries.integrate_model_with_control_CNAB-Tuple{Any, Any, Any}","page":"Modified Korteweg-de Vries Equation","title":"PolynomialModelReductionDataset.ModifiedKortewegDeVries.integrate_model_with_control_CNAB","text":"integrate_model_with_control_CNAB(\n    tdata,\n    u0,\n    input;\n    linear_matrix,\n    cubic_matrix,\n    control_matrix,\n    const_stepsize,\n    u3_jm1\n)\n\n\nCrank-Nicolson Adam-Bashforth (CNAB) scheme with control\n\n\n\n\n\n","category":"method"},{"location":"1D/mKdV/#PolynomialModelReductionDataset.ModifiedKortewegDeVries.integrate_model_with_control_SIE-Tuple{Any, Any, Any}","page":"Modified Korteweg-de Vries Equation","title":"PolynomialModelReductionDataset.ModifiedKortewegDeVries.integrate_model_with_control_SIE","text":"integrate_model_with_control_SIE(\n    tdata,\n    u0,\n    input;\n    linear_matrix,\n    cubic_matrix,\n    control_matrix\n)\n\n\nSemi-Implicit Euler (SIE) scheme with control\n\n\n\n\n\n","category":"method"},{"location":"1D/mKdV/#PolynomialModelReductionDataset.ModifiedKortewegDeVries.integrate_model_without_control_CNAB-Tuple{Any, Any}","page":"Modified Korteweg-de Vries Equation","title":"PolynomialModelReductionDataset.ModifiedKortewegDeVries.integrate_model_without_control_CNAB","text":"integrate_model_without_control_CNAB(\n    tdata,\n    u0;\n    linear_matrix,\n    cubic_matrix,\n    const_stepsize,\n    u3_jm1\n)\n\n\nCrank-Nicolson Adam-Bashforth (CNAB) scheme without control\n\n\n\n\n\n","category":"method"},{"location":"1D/mKdV/#PolynomialModelReductionDataset.ModifiedKortewegDeVries.integrate_model_without_control_SIE-Tuple{Any, Any}","page":"Modified Korteweg-de Vries Equation","title":"PolynomialModelReductionDataset.ModifiedKortewegDeVries.integrate_model_without_control_SIE","text":"integrate_model_without_control_SIE(\n    tdata,\n    u0;\n    linear_matrix,\n    cubic_matrix\n)\n\n\nSemi-Implicit Euler (SIE) scheme without control\n\n\n\n\n\n","category":"method"}]
}
